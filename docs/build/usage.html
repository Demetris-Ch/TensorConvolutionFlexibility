

<!DOCTYPE html>
<html class="writer-html5" lang="en" data-content_root="./">
<head>
  <meta charset="utf-8" /><meta name="viewport" content="width=device-width, initial-scale=1" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Usage &mdash; TensorConvolutionPlus 1.0 documentation</title>
      <link rel="stylesheet" type="text/css" href="_static/pygments.css?v=80d5e7a1" />
      <link rel="stylesheet" type="text/css" href="_static/css/theme.css?v=e59714d7" />

  
      <script src="_static/jquery.js?v=5d32c60e"></script>
      <script src="_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
      <script src="_static/documentation_options.js?v=f2a433a1"></script>
      <script src="_static/doctools.js?v=888ff710"></script>
      <script src="_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="_static/js/theme.js"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="API" href="api.html" />
    <link rel="prev" title="Welcome to TensorConvolutionPlus’s documentation!" href="index.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="index.html" class="icon icon-home">
            TensorConvolutionPlus
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul class="current">
<li class="toctree-l1 current"><a class="current reference internal" href="#">Usage</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#i-reference">I. Reference</a></li>
<li class="toctree-l2"><a class="reference internal" href="#ii-acknowledgements">II. Acknowledgements</a></li>
<li class="toctree-l2"><a class="reference internal" href="#iii-package">III. Package</a></li>
<li class="toctree-l2"><a class="reference internal" href="#iv-examples">IV. Examples</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#iv-a-monte-carlo-power-flow">IV.A) Monte Carlo Power Flow</a></li>
<li class="toctree-l3"><a class="reference internal" href="#iv-b-exhaustive-power-flow">IV.B) Exhaustive Power Flow</a></li>
<li class="toctree-l3"><a class="reference internal" href="#iv-c-optimal-power-flow">IV.C) Optimal Power Flow</a></li>
<li class="toctree-l3"><a class="reference internal" href="#iv-d-tensorconvolution">IV.D) TensorConvolution+</a></li>
<li class="toctree-l3"><a class="reference internal" href="#iv-e-tensorconvolution-merge">IV.E) TensorConvolution+ Merge</a></li>
<li class="toctree-l3"><a class="reference internal" href="#iv-f-tensorconvolution-adapt">IV.F) TensorConvolution+ Adapt</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#v-functions">V. Functions</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#package-functionalities">Package Functionalities</a></li>
<li class="toctree-l3"><a class="reference internal" href="#convolution-simulations">Convolution Simulations</a></li>
<li class="toctree-l3"><a class="reference internal" href="#monte-carlo">Monte Carlo</a></li>
<li class="toctree-l3"><a class="reference internal" href="#data-sampler">Data Sampler</a></li>
<li class="toctree-l3"><a class="reference internal" href="#json-reader">Json Reader</a></li>
<li class="toctree-l3"><a class="reference internal" href="#plotting">Plotting</a></li>
<li class="toctree-l3"><a class="reference internal" href="#scenario-setup">Scenario Setup</a></li>
<li class="toctree-l3"><a class="reference internal" href="#accuracy-estimation">Accuracy Estimation</a></li>
<li class="toctree-l3"><a class="reference internal" href="#utils">Utils</a></li>
<li class="toctree-l3"><a class="reference internal" href="#optimal-power-flow">Optimal power flow</a></li>
<li class="toctree-l3"><a class="reference internal" href="#main">Main</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#vi-files-for-ieee-transactions-on-smart-grid-publication-scenarios">VI. Files for IEEE Transactions on Smart Grid Publication Scenarios</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#vi-a-accuracy-in-population-estimation">VI.A) Accuracy in Population Estimation</a></li>
<li class="toctree-l3"><a class="reference internal" href="#vi-b-speed-and-range-accuracy">VI.B) Speed and Range Accuracy</a></li>
<li class="toctree-l3"><a class="reference internal" href="#vi-c-disjoint-flexibility-areas">VI.C) Disjoint Flexibility Areas</a></li>
<li class="toctree-l3"><a class="reference internal" href="#vi-d-uncertainty-estimation-for-small-fsps">VI.D) Uncertainty Estimation for Small FSPs</a></li>
<li class="toctree-l3"><a class="reference internal" href="#vi-e-adaptability">VI.E) Adaptability</a></li>
<li class="toctree-l3"><a class="reference internal" href="#vi-f-case-study-for-dfc">VI.F) Case study for DFC</a></li>
<li class="toctree-l3"><a class="reference internal" href="#vi-g-case-study-for-opfs">VI.G) Case study for OPFs</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="api.html">API</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">TensorConvolutionPlus</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="index.html" class="icon icon-home" aria-label="Home"></a></li>
      <li class="breadcrumb-item active">Usage</li>
      <li class="wy-breadcrumbs-aside">
            <a href="_sources/usage.rst.txt" rel="nofollow"> View page source</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section id="usage">
<h1>Usage<a class="headerlink" href="#usage" title="Link to this heading"></a></h1>
<section id="i-reference">
<h2>I. Reference<a class="headerlink" href="#i-reference" title="Link to this heading"></a></h2>
<p>The package documentation preprint is currently available in ArXiv under:</p>
<p>[![DOI](<a class="reference external" href="https://doi.org/10.1109/TSG.2024.3453667">https://doi.org/10.1109/TSG.2024.3453667</a>)</p>
<p>Available at: <a class="reference external" href="https://ieeexplore.ieee.org/document/10663439">https://ieeexplore.ieee.org/document/10663439</a></p>
<p>The TensorConvolution+ algorithm was published in IEEE Transactions on Smart Grid and can be read and referenced using:</p>
<p>[![DOI](<a class="reference external" href="https://doi.org/10.1109/TSG.2024.3453667">https://doi.org/10.1109/TSG.2024.3453667</a>)</p>
<p>Available at: <a class="reference external" href="https://ieeexplore.ieee.org/document/10663439">https://ieeexplore.ieee.org/document/10663439</a></p>
</section>
<section id="ii-acknowledgements">
<h2>II. Acknowledgements<a class="headerlink" href="#ii-acknowledgements" title="Link to this heading"></a></h2>
<p>The authors are part of the IEPG group and AI Energy lab of TU Delft.
This research is part of the research program ‘MegaMind - Measuring, Gathering, Mining and Integrating Data for Self-management in the Edge of the Electricity System’, (partly) financed by the Dutch Research Council (NWO) through the Perspectief program under number P19-25.</p>
<a class="reference internal image-reference" href="/plots/IEPG_logo.jpg"><img alt="/plots/IEPG_logo.jpg" src="/plots/IEPG_logo.jpg" style="width: 150px;" /></a>
<a class="reference internal image-reference" href="/plots/DAI_Energy_logo.png"><img alt="/plots/DAI_Energy_logo.png" src="/plots/DAI_Energy_logo.png" style="width: 150px;" /></a>
<a class="reference internal image-reference" href="/plots/Tu-delft.png"><img alt="/plots/Tu-delft.png" src="/plots/Tu-delft.png" style="width: 150px;" /></a>
<a class="reference internal image-reference" href="/plots/MegaMindLogo.png"><img alt="/plots/MegaMindLogo.png" src="/plots/MegaMindLogo.png" style="width: 120px;" /></a>
</section>
<section id="iii-package">
<h2>III. Package<a class="headerlink" href="#iii-package" title="Link to this heading"></a></h2>
<p>The proposed package includes the functionalities to perform flexibility area estimation.</p>
<p>To install the package using pip, run:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp gp-VirtualEnv">(.venv)</span> <span class="gp">$ </span>pip<span class="w"> </span>install<span class="w"> </span>tensorconvolutionplus
</pre></div>
</div>
<p>To install the package through a file, place the <strong>tensorconvolutionplus-0.1.0.tar.gz</strong> file in an accessible path and run:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp gp-VirtualEnv">(.venv)</span> <span class="gp">$ </span>pip<span class="w"> </span>install<span class="w"> </span>path/to/package/tensorconvolutionplus-0.1.0.tar.gz
</pre></div>
</div>
<p>Main functionalities include:</p>
<ol class="arabic simple">
<li><dl class="simple">
<dt>TensorConvolution+, estimating FAs using the TensorConvolution+ algorithm. In the current version, the estimations can vary in:</dt><dd><ul class="simple">
<li><p>Pandapower network (names) for MV Oberrhein0, MV Oberrhein1, Cigre MV. If another network is in similar format as these pandapower networks, it can also be an input instead.</p></li>
<li><p>Resolutions for the discretization of the flexibility resources.</p></li>
<li><p>Network voltage and loading constraints.</p></li>
<li><p>Voltage and loading sensitivity thresholds.</p></li>
<li><p>Including/Excluding FSPs only offering full output reductions, or limited setpoints ( including these FSPs currently uses the numpy library and not pytorch).</p></li>
<li><p>Flexibility service providers.</p></li>
<li><p>Network structure and initial operating conditions.</p></li>
<li><dl class="simple">
<dt>Shape of flexibility resources. Currently FSP limits are:</dt><dd><ul>
<li><p>the output cannot exceed the maximum apparent power of the FSP (resulting in a semi-oval shape),</p></li>
<li><p>the output P cannot exceed the maximum apparent power of the FSP, the output abs(Q) cannot exceed the maximum apparent power of the FSP (resulting in rectangular shape).</p></li>
<li><p>additional shapes can be adopted by modifying the sample generation function (not impacting the TensorConvolution+ aggregation).</p></li>
</ul>
</dd>
</dl>
</li>
</ul>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>TensorConvolution+, while storing estimated tensors and other useful information to adapt flexibility areas for different operating conditions. In the current version, the estimations can vary in:</dt><dd><ul class="simple">
<li><p>Pandapower network (names) for MV Oberrhein0, MV Oberrhein1, Cigre MV. If another network is in similar format as these pandapower networks, it can also be an input instead.</p></li>
<li><p>Resolutions for the discretization of the flexibility resources.</p></li>
<li><p>Network voltage and loading constraints.</p></li>
<li><p>Voltage and loading sensitivity thresholds.</p></li>
<li><p>Flexibility service providers.</p></li>
<li><p>Network structure and initial operating conditions.</p></li>
<li><dl class="simple">
<dt>Shape of flexibility resources. Currently FSP limits are:</dt><dd><ul>
<li><p>the output cannot exceed the maximum apparent power of the FSP (resulting in a semi-oval shape),</p></li>
<li><p>the output P cannot exceed the maximum apparent power of the FSP, the output abs(Q) cannot exceed the maximum apparent power of the FSP (resulting in rectangular shape).</p></li>
<li><p>additional shapes can be adopted by modifying the sample generation function (not impacting the TensorConvolution+ aggregation).</p></li>
</ul>
</dd>
</dl>
</li>
</ul>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>TensorConvolution+, while loading previously estimated tensors and other useful information to adapt flexibility areas from prior different operating conditions. In the current version, the estimations can vary in:</dt><dd><ul class="simple">
<li><p>Pandapower network (names) for MV Oberrhein0, MV Oberrhein1, Cigre MV. If another network is in similar format as these pandapower networks, it can also be an input instead. The network must be the same as the stored one.</p></li>
<li><p>Resolutions for the discretization of the flexibility resources. Must be the same as the stored simulation.</p></li>
<li><p>Network voltage and loading constraints.</p></li>
<li><p>Flexibility service providers.  Must be the same as the stored simulation.</p></li>
<li><p>Network structure and initial operating conditions.</p></li>
<li><p>Shape of flexibility resources.  Must be the same as the stored simulation.</p></li>
</ul>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>Monte Carlo power flow based flexibility area estimation. In the current version, the estimations can vary in:</dt><dd><ul class="simple">
<li><p>Pandapower network (names) for MV Oberrhein0, MV Oberrhein1, Cigre MV. If another network is in similar format as these pandapower networks, it can also be an input instead.</p></li>
<li><p>Network voltage and loading constraints.</p></li>
<li><p>Number of samples.</p></li>
<li><dl class="simple">
<dt>Distribution used for samples, including:</dt><dd><ul>
<li><p>‘Hard’: Exploring the limit from each resource flexibility.</p></li>
<li><p>‘Uniform’: Applying uniform distribution.</p></li>
<li><p>‘Kumaraswamy’: Applying the Kumaraswamy distribution.</p></li>
</ul>
</dd>
</dl>
</li>
<li><p>Flexibility service providers.</p></li>
<li><p>Including/Excluding FSPs only offering full output reductions, or limited setpoints (including these FSPs currently uses the numpy library and not pytorch).</p></li>
<li><p>Network structure and initial operating conditions.</p></li>
</ul>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>Exhaustive power flow based flexibility area estimation. In the current version, the estimations can vary in:</dt><dd><ul class="simple">
<li><p>Pandapower network (names) for MV Oberrhein0, MV Oberrhein1, Cigre MV. If another network is in similar format as these pandapower networks, it can also be an input instead.</p></li>
<li><p>Network voltage and loading constraints.</p></li>
<li><p>Resolutions for the discretization of the flexibility resources.</p></li>
<li><p>Flexibility service providers.</p></li>
<li><p>Including/Excluding FSPs only offering full output reductions, or limited setpoints (including these FSPs currently uses the numpy library and not pytorch).</p></li>
<li><p>Network structure and initial operating conditions.</p></li>
</ul>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>Optimal power flow based flexibility area estimation. In the current version, the estimations can vary in:</dt><dd><ul class="simple">
<li><p>Pandapower network. Cigre MV in radial structure converges whereas alternative networks might fail to converge.</p></li>
<li><p>Network voltage and loading constraints. Transformer loading is excluded due to convergence issues.</p></li>
<li><p>Flexibility service providers.</p></li>
<li><p>Network structure and initial operating conditions.</p></li>
</ul>
</dd>
</dl>
</li>
</ol>
</section>
<section id="iv-examples">
<h2>IV. Examples<a class="headerlink" href="#iv-examples" title="Link to this heading"></a></h2>
<p>All main functionalities require first importing the FA_Estimator script from the package. Therefore, all the following examples start with the Python line:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="go">from TensorConvolutionPlus import FA_Estimator as TCP</span>
</pre></div>
</div>
<section id="iv-a-monte-carlo-power-flow">
<h3>IV.A) Monte Carlo Power Flow<a class="headerlink" href="#iv-a-monte-carlo-power-flow" title="Link to this heading"></a></h3>
<p>This section includes examples using the Monte Carlo PF estimation functionality. These examples used the Python script code:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="go">TCP.monte_carlo_pf(net_name=&#39;MV Oberrhein0&#39;, no_samples=6000, fsp_load_indices=[1, 2, 3], fsp_dg_indices=[1, 2, 3], distribution=&#39;Uniform&#39;)</span>

<span class="go">TCP.monte_carlo_pf(net_name=&#39;MV Oberrhein0&#39;, no_samples=6000, fsp_load_indices=[1, 2, 3], fsp_dg_indices=[1, 2, 3], distribution=&#39;Kumaraswamy&#39;)</span>

<span class="go">TCP.monte_carlo_pf(net_name=&#39;MV Oberrhein0&#39;, no_samples=6000, fsp_load_indices=[1, 2, 3], fsp_dg_indices=[1, 2, 3])</span>

<span class="go">TCP.monte_carlo_pf(net_name=&#39;MV Oberrhein0&#39;, no_samples=12000, fsp_load_indices=[1, 2, 3], fsp_dg_indices=[1, 2, 3])</span>
</pre></div>
</div>
<p>The examples vary in sampling distribution and number of samples.
The figures bellow illustrate the resulting FA for each line respectively. The lines without <em>distribution</em> input automatically obtain the ‘Hard’ distribution.</p>
<a class="reference internal image-reference" href="/plots/MonteCarlo2024-11-08_14-30-32_incl_infeasible.jpg"><img alt="/plots/MonteCarlo2024-11-08_14-30-32_incl_infeasible.jpg" src="/plots/MonteCarlo2024-11-08_14-30-32_incl_infeasible.jpg" style="width: 400px;" /></a>
<a class="reference internal image-reference" href="/plots/MonteCarlo2024-11-08_14-25-40_incl_infeasible.jpg"><img alt="/plots/MonteCarlo2024-11-08_14-25-40_incl_infeasible.jpg" src="/plots/MonteCarlo2024-11-08_14-25-40_incl_infeasible.jpg" style="width: 400px;" /></a>
<a class="reference internal image-reference" href="/plots/MonteCarlo2024-11-05_17-06-58_incl_infeasible.jpg"><img alt="/plots/MonteCarlo2024-11-05_17-06-58_incl_infeasible.jpg" src="/plots/MonteCarlo2024-11-05_17-06-58_incl_infeasible.jpg" style="width: 400px;" /></a>
<a class="reference internal image-reference" href="/plots/MonteCarlo2024-11-08_13-15-01_incl_infeasible.jpg"><img alt="/plots/MonteCarlo2024-11-08_13-15-01_incl_infeasible.jpg" src="/plots/MonteCarlo2024-11-08_13-15-01_incl_infeasible.jpg" style="width: 400px;" /></a>
</section>
<section id="iv-b-exhaustive-power-flow">
<h3>IV.B) Exhaustive Power Flow<a class="headerlink" href="#iv-b-exhaustive-power-flow" title="Link to this heading"></a></h3>
<p>This section includes examples using the exhaustive power flow-based functionality. The script for the examples is:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="go">TCP.exhaustive_pf(net_name=&#39;MV Oberrhein0&#39;, dp=0.15, dq=0.3, fsp_load_indices=[1, 2, 3], fsp_dg_indices=[1, 2, 3])</span>

<span class="go">TCP.exhaustive_pf(net_name=&#39;MV Oberrhein0&#39;, dp=0.01, dq=0.02, fsp_load_indices=[5], fsp_dg_indices=[5])</span>
</pre></div>
</div>
<p>The examples vary in resolution and number of FSPs.
The figures bellow illustrate the resulting FA for each line respectively.</p>
<a class="reference internal image-reference" href="/plots/ExhaustivePowerFlow2024-11-05_17-00-00_incl_infeasible.png"><img alt="/plots/ExhaustivePowerFlow2024-11-05_17-00-00_incl_infeasible.png" src="/plots/ExhaustivePowerFlow2024-11-05_17-00-00_incl_infeasible.png" style="width: 380px;" /></a>
<a class="reference internal image-reference" href="/plots/ExhaustivePowerFlow2024-11-08_14-10-05_incl_infeasible.jpg"><img alt="/plots/ExhaustivePowerFlow2024-11-08_14-10-05_incl_infeasible.jpg" src="/plots/ExhaustivePowerFlow2024-11-08_14-10-05_incl_infeasible.jpg" style="width: 400px;" /></a>
</section>
<section id="iv-c-optimal-power-flow">
<h3>IV.C) Optimal Power Flow<a class="headerlink" href="#iv-c-optimal-power-flow" title="Link to this heading"></a></h3>
<p>This section illustrates examples using the OPF estimation functionality. These examples used the Python script code:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="go">TCP.opf(net_name=&#39;CIGRE MV&#39;, opf_step=0.1, fsp_load_indices=[3, 5, 8], fsp_dg_indices=[8])</span>

<span class="go">TCP.opf(net_name=&#39;CIGRE MV&#39;, opf_step=0.1, fsp_load_indices=[1, 4, 9], fsp_dg_indices=[8])</span>
</pre></div>
</div>
<p>The examples vary in FSPs.
The figures bellow illustrate the resulting FA for each line respectively.</p>
<a class="reference internal image-reference" href="/plots/OptimalPowerFlow2024-11-12_17-40-42.jpg"><img alt="/plots/OptimalPowerFlow2024-11-12_17-40-42.jpg" src="/plots/OptimalPowerFlow2024-11-12_17-40-42.jpg" style="width: 400px;" /></a>
<a class="reference internal image-reference" href="/plots/OptimalPowerFlow2024-11-12_17-47-00.jpg"><img alt="/plots/OptimalPowerFlow2024-11-12_17-47-00.jpg" src="/plots/OptimalPowerFlow2024-11-12_17-47-00.jpg" style="width: 400px;" /></a>
</section>
<section id="iv-d-tensorconvolution">
<h3>IV.D) TensorConvolution+<a class="headerlink" href="#iv-d-tensorconvolution" title="Link to this heading"></a></h3>
<p>This section illustrates examples using the TensorConvolution+ FA estimation functionality. The first examples, showcasing the different shapes of flexibility from FSPs use the lines:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="go">TCP.tc_plus(net_name=&#39;MV Oberrhein0&#39;, fsp_load_indices=[1, 2, 3], dp=0.05, dq=0.1, fsp_dg_indices=[1, 2, 3])</span>

<span class="go">TCP.tc_plus(net_name=&#39;MV Oberrhein0&#39;, fsp_load_indices=[1, 2], dp=0.05, dq=0.1, fsp_dg_indices=[1, 2], flex_shape=&#39;PQmax&#39;)</span>
</pre></div>
</div>
<p>The examples vary in number of FSPs and shapes of flexibility offers. The example without the <em>flex_shape</em> input automatically obtains the value ‘Smax’.
The figures bellow illustrate the resulting FA for each line respectively.</p>
<a class="reference internal image-reference" href="/plots/TensorConvolutionPlus2024-11-05_18-18-32.jpg"><img alt="/plots/TensorConvolutionPlus2024-11-05_18-18-32.jpg" src="/plots/TensorConvolutionPlus2024-11-05_18-18-32.jpg" style="width: 400px;" /></a>
<a class="reference internal image-reference" href="/plots/TensorConvolutionPlus2024-11-08_14-38-25.jpg"><img alt="/plots/TensorConvolutionPlus2024-11-08_14-38-25.jpg" src="/plots/TensorConvolutionPlus2024-11-08_14-38-25.jpg" style="width: 400px;" /></a>
<p>TensorConvolution+ can also simulate FAs with FSPs offering discrete setpoints of flexibility. For such scenarios, the input <em>non_linear_fsps</em> specifies which of the FSPs are non linear. The example line is:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="go">TCP.tc_plus(net_name=&#39;CIGRE MV&#39;, fsp_load_indices=[3, 4, 5], dp=0.05, dq=0.1, fsp_dg_indices=[8], non_linear_fsps=[8])</span>
</pre></div>
</div>
<p>The resulting figure is:</p>
<a class="reference internal image-reference" href="/plots/TensorConvolutionPlus2024-11-08_17-08-10.jpg"><img alt="/plots/TensorConvolutionPlus2024-11-08_17-08-10.jpg" src="/plots/TensorConvolutionPlus2024-11-08_17-08-10.jpg" style="width: 400px;" /></a>
</section>
<section id="iv-e-tensorconvolution-merge">
<h3>IV.E) TensorConvolution+ Merge<a class="headerlink" href="#iv-e-tensorconvolution-merge" title="Link to this heading"></a></h3>
<p>This section showcases the function merging FSPs using the TensorConvolution+ algorithm.
For this functionality, the <em>max_fsps</em> input determines the maximum FSPs for which a network component can be sensitive before merging their flexibility.
The example line is:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="go">TCP.tc_plus_merge(net_name=&#39;MV Oberrhein0&#39;, fsp_load_indices=[1, 2, 3], dp=0.025, dq=0.05, fsp_dg_indices=[1, 2, 3], max_fsps=5)</span>
</pre></div>
</div>
<p>The resulting figure is:</p>
<a class="reference internal image-reference" href="/plots/TensorConvolutionPlusMegeFSPs2024-11-08_17-13-06.jpg"><img alt="/plots/TensorConvolutionPlusMegeFSPs2024-11-08_17-13-06.jpg" src="/plots/TensorConvolutionPlusMegeFSPs2024-11-08_17-13-06.jpg" style="width: 400px;" /></a>
</section>
<section id="iv-f-tensorconvolution-adapt">
<h3>IV.F) TensorConvolution+ Adapt<a class="headerlink" href="#iv-f-tensorconvolution-adapt" title="Link to this heading"></a></h3>
<p>This section showcases the function storing information using the TensorConvolution+ algorithm, and then uses the stored information to adapt flexibility area for altered operating conditions.</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="gp"># </span>Define<span class="w"> </span>the<span class="w"> </span>consistent<span class="w"> </span>FSPs<span class="w"> </span><span class="k">for</span><span class="w"> </span>the<span class="w"> </span>storing<span class="w"> </span>and<span class="w"> </span>adapting<span class="w"> </span>functions
<span class="go">fsp_load_indices = [1, 2, 3]</span>
<span class="go">fsp_dg_indices = [1, 2, 3]</span>

<span class="gp"># </span>Estimate<span class="w"> </span>the<span class="w"> </span>FA<span class="w"> </span>and<span class="w"> </span>store<span class="w"> </span>the<span class="w"> </span>relevant<span class="w"> </span>information<span class="w"> </span><span class="k">for</span><span class="w"> </span>adaptation
<span class="go">TCP.tc_plus_save_tensors(net_name=&#39;MV Oberrhein0&#39;, fsp_load_indices=fsp_load_indices, dp=0.05, dq=0.1, fsp_dg_indices=fsp_dg_indices)</span>

<span class="gp"># </span>Modify<span class="w"> </span>the<span class="w"> </span>network<span class="w"> </span>operating<span class="w"> </span>conditions
<span class="go">net, net_tmp = pn.mv_oberrhein(separation_by_sub=True)</span>
<span class="go">net.load[&#39;sn_mva&#39;] = list(net.load[&#39;p_mw&#39;].pow(2).add(net.load[&#39;q_mvar&#39;].pow(2)).pow(0.5))</span>
<span class="go">net.load[&#39;scaling&#39;] = [1 for i in range(len(net.load))]</span>
<span class="go">net.sgen[&#39;scaling&#39;] = [1 for i in range(len(net.sgen))]</span>
<span class="go">net.switch[&#39;closed&#39;] = [True for i in range(len(net.switch))]</span>

<span class="go">net = fix_net(net) # This function is included in the appendix</span>

<span class="go">rng = np.random.RandomState(212)</span>

<span class="go">net, rng = rand_resample(net, fsp_load_indices, fsp_dg_indices, rng, 0.05, 0.01, 0.05, 0.01) # This function is also included in the appendix</span>

<span class="gp"># </span>Adapt<span class="w"> </span>the<span class="w"> </span>FA<span class="w"> </span>using<span class="w"> </span>the<span class="w"> </span>locally<span class="w"> </span>stored<span class="w"> </span>information
<span class="go">TCP.tc_plus_adapt(net=net, fsp_load_indices=fsp_load_indices, fsp_dg_indices=fsp_dg_indices)</span>

<span class="gp"># </span>Estimate<span class="w"> </span>the<span class="w"> </span>FA<span class="w"> </span>without<span class="w"> </span>adapting<span class="w"> </span>to<span class="w"> </span>compare<span class="w"> </span>with<span class="w"> </span>the<span class="w"> </span>above<span class="w"> </span>adapted<span class="w"> </span>result
<span class="go">TCP.tc_plus(net=net, fsp_load_indices=fsp_load_indices, fsp_dg_indices=fsp_dg_indices, dp=0.05, dq=0.1)</span>
</pre></div>
</div>
<p>The resulting figures for the stored, adapted and validated flexibility areas are:</p>
<a class="reference internal image-reference" href="/plots/TensorConvolutionPlusStore2024-11-08_17-44-24.jpg"><img alt="/plots/TensorConvolutionPlusStore2024-11-08_17-44-24.jpg" src="/plots/TensorConvolutionPlusStore2024-11-08_17-44-24.jpg" style="width: 400px;" /></a>
<a class="reference internal image-reference" href="/plots/TensorConvolutionPlusAdapt2024-11-08_17-59-04.jpg"><img alt="/plots/TensorConvolutionPlusAdapt2024-11-08_17-59-04.jpg" src="/plots/TensorConvolutionPlusAdapt2024-11-08_17-59-04.jpg" style="width: 400px;" /></a>
<a class="reference internal image-reference" href="/plots/TensorConvolutionPlus2024-11-08_17-59-28.jpg"><img alt="/plots/TensorConvolutionPlus2024-11-08_17-59-28.jpg" src="/plots/TensorConvolutionPlus2024-11-08_17-59-28.jpg" style="width: 400px;" /></a>
</section>
</section>
<section id="v-functions">
<h2>V. Functions<a class="headerlink" href="#v-functions" title="Link to this heading"></a></h2>
<section id="package-functionalities">
<h3>Package Functionalities<a class="headerlink" href="#package-functionalities" title="Link to this heading"></a></h3>
<p>This Python Script includes all functions of the developed package.</p>
<dl class="py function">
<dt class="sig sig-object py">
<span class="sig-prename descclassname"><span class="pre">FA_Estimator.</span></span><span class="sig-name descname"><span class="pre">exhaustive_pf</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">net</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">net_name</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">'MV</span> <span class="pre">Oberrhein0'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dp</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">0.05</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dq</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">0.05</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">max_curr_per</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">100</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">max_volt_pu</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">1.05</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">min_volt_pu</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">0.95</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">non_linear_fsps</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">list</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">[]</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fsp_load_indices</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">list</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">[]</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fsp_dg_indices</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">list</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">[]</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">scenario_type</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">dict</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">{'name':</span> <span class="pre">'CS',</span> <span class="pre">'no.':</span> <span class="pre">0}</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>Package Function to run the exhaustive power flow algorithm.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>net</strong> (<em>pp.networks</em>) – pandapower network (optional). Default=None.</p></li>
<li><p><strong>net_name</strong> (<em>str</em>) – network name (optional, only used if network is not given). Default=’MV Oberrhein0’.</p></li>
<li><p><strong>dp</strong> (<em>float</em>) – step size in active power (optional). Default=0.05.</p></li>
<li><p><strong>dq</strong> (<em>float</em>) – step size in reactive power (optional). Default=0.05.</p></li>
<li><p><strong>max_curr_per</strong> (<em>int</em>) – network maximum current constraint (optional). Default=100.</p></li>
<li><p><strong>max_volt_pu</strong> (<em>float</em>) – network maximum voltage constraint (optional). Default=1.05.</p></li>
<li><p><strong>min_volt_pu</strong> (<em>float</em>) – network minimum voltage constraint (optional). Default=0.95.</p></li>
<li><p><strong>non_linear_fsps</strong> (<em>list</em>) – indices of non linear_fsps, offering 2 setpoints (optional). Default=[].</p></li>
<li><p><strong>fsp_load_indices</strong> (<em>list</em>) – indices of load FSPs (optional, but at least one of fsp_load_indices or fsp_dg_indices should be non-empty). Default=[].</p></li>
<li><p><strong>fsp_dg_indices</strong> (<em>list</em>) – indices of DG FSPs (optional, but at least one of fsp_load_indices or fsp_dg_indices should be non-empty). Default=[].</p></li>
<li><p><strong>scenario_type</strong> (<em>dict</em>) – Scenario for network settings (e.g.CS=closed switches, only used if net is None). Default={“name”: ‘CS’, “no.”: 0}.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>Flexibility area plot and csv of dataframe are stored locally. The function returns nothing.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>None</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py">
<span class="sig-prename descclassname"><span class="pre">FA_Estimator.</span></span><span class="sig-name descname"><span class="pre">monte_carlo_pf</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">net</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">net_name</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">'MV</span> <span class="pre">Oberrhein0'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">max_curr_per</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">100</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">max_volt_pu</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">1.05</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">min_volt_pu</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">0.95</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">no_samples</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">10000</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">distribution</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">'Hard'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">non_linear_fsps</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">list</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">[]</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fsp_load_indices</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">list</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">[]</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fsp_dg_indices</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">list</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">[]</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">scenario_type</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">dict</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">{'name':</span> <span class="pre">'CS',</span> <span class="pre">'no.':</span> <span class="pre">0}</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>Package Function to run the Monte Carlo based power flow algorithm.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>net</strong> (<em>pp.networks</em>) – pandapower network (optional). Default=None.</p></li>
<li><p><strong>net_name</strong> (<em>str</em>) – network name (optional, only used if network is not given). Default=’MV Oberrhein0’.</p></li>
<li><p><strong>max_curr_per</strong> (<em>int</em>) – network maximum current constraint (optional). Default=100.</p></li>
<li><p><strong>max_volt_pu</strong> (<em>float</em>) – network maximum voltage constraint (optional). Default=1.05.</p></li>
<li><p><strong>min_volt_pu</strong> (<em>float</em>) – network minimum voltage constraint (optional). Default=0.95.</p></li>
<li><p><strong>no_samples</strong> (<em>int</em>) – number of samples for power flows (optional). Default=1000.</p></li>
<li><p><strong>distribution</strong> (<em>str</em>) – distribution used for generated samples for power flows (optional). Default=’Hard’.</p></li>
<li><p><strong>non_linear_fsps</strong> (<em>list</em>) – indices of non linear_fsps, offering 2 setpoints (optional). Default=[].</p></li>
<li><p><strong>fsp_load_indices</strong> (<em>list</em>) – indices of load FSPs (optional, but at least one of fsp_load_indices or fsp_dg_indices should be non-empty). Default=[].</p></li>
<li><p><strong>fsp_dg_indices</strong> (<em>list</em>) – indices of DG FSPs (optional, but at least one of fsp_load_indices or fsp_dg_indices should be non-empty). Default=[].</p></li>
<li><p><strong>scenario_type</strong> (<em>dict</em>) – Scenario for network settings (e.g.CS=closed switches, only used if net is None). Default={“name”: ‘CS’, “no.”: 0}.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>Flexibility area plot and csv of dataframe are stored locally. The function returns nothing.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>None</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py">
<span class="sig-prename descclassname"><span class="pre">FA_Estimator.</span></span><span class="sig-name descname"><span class="pre">opf</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">net</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">net_name</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">'MV</span> <span class="pre">Cigre'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">opf_step</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">0.1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">max_curr_per</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">100</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">max_volt_pu</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">1.05</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">min_volt_pu</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">0.95</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fsp_load_indices</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">list</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">[]</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fsp_dg_indices</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">list</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">[]</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">scenario_type</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">dict</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">{'name':</span> <span class="pre">'CS',</span> <span class="pre">'no.':</span> <span class="pre">101}</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>Package function to run the optimal power flow algorithm. This function has convergence issues, where only Cigre MV network converges and without transformer loading contraints.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>net</strong> (<em>pp.networks</em>) – pandapower network (optional). Default=None.</p></li>
<li><p><strong>net_name</strong> (<em>str</em>) – network name (optional, only used if network is not given). Default=’MV Cigre’, currently the only converging option.</p></li>
<li><p><strong>opf_step</strong> (<em>float</em>) – OPF step size. Default=0.1.</p></li>
<li><p><strong>max_curr_per</strong> (<em>int</em>) – network maximum current constraint (optional). Default=100.</p></li>
<li><p><strong>max_volt_pu</strong> (<em>float</em>) – network maximum voltage constraint (optional). Default=1.05.</p></li>
<li><p><strong>min_volt_pu</strong> (<em>float</em>) – network minimum voltage constraint (optional). Default=0.95.</p></li>
<li><p><strong>fsp_load_indices</strong> (<em>list</em>) – indices of load FSPs (optional, but at least one of fsp_load_indices or fsp_dg_indices should be non-empty). Default=[].</p></li>
<li><p><strong>fsp_dg_indices</strong> (<em>list</em>) – indices of DG FSPs (optional, but at least one of fsp_load_indices or fsp_dg_indices should be non-empty). Default=[].</p></li>
<li><p><strong>scenario_type</strong> (<em>dict</em>) – Scenario for network settings (e.g.CS=closed switches, only used if net is None). Default={“name”: ‘CS’, “no.”: 101}.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>Flexibility area plot is stored locally. The function returns nothing.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>None</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py">
<span class="sig-prename descclassname"><span class="pre">FA_Estimator.</span></span><span class="sig-name descname"><span class="pre">tc_plus</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">net</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">net_name</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">'MV</span> <span class="pre">Oberrhein0'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dp</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">0.05</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dq</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">0.05</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">max_curr_per</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">100</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">max_volt_pu</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">1.05</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">min_volt_pu</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">0.95</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">l_sens</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">v_sens</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">0.001</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">non_linear_fsps</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">list</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">[]</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fsp_load_indices</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">list</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">[]</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fsp_dg_indices</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">list</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">[]</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">scenario_type</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">dict</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">{'name':</span> <span class="pre">'CS',</span> <span class="pre">'no.':</span> <span class="pre">0}</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">flex_shape</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">'Smax'</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>Package Function to run the TensorConvolution+ algorithm.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>net</strong> (<em>pp.networks</em>) – Pandapower network (optional). Default=None.</p></li>
<li><p><strong>net_name</strong> (<em>str</em>) – Network name (optional, only used if network is not given). Default=’MV Oberrhein0’.</p></li>
<li><p><strong>dp</strong> (<em>float</em>) – step size in active power (optional). Default=0.05.</p></li>
<li><p><strong>dq</strong> (<em>float</em>) – step size in reactive power (optional). Default=0.05.</p></li>
<li><p><strong>max_curr_per</strong> (<em>int</em>) – network maximum current constraint (optional). Default=100.</p></li>
<li><p><strong>max_volt_pu</strong> (<em>float</em>) – network maximum voltage constraint (optional). Default=1.05.</p></li>
<li><p><strong>min_volt_pu</strong> (<em>float</em>) – network minimum voltage constraint (optional). Default=0.95.</p></li>
<li><p><strong>l_sens</strong> (<em>float</em>) – loading sensitivity threshold (optional). Default=1.</p></li>
<li><p><strong>v_sens</strong> (<em>float</em>) – voltage sensitivity threshold (optional). Default=0.001.</p></li>
<li><p><strong>non_linear_fsps</strong> (<em>list</em>) – indices of non linear_fsps, offering 2 setpoints (optional). Default=[].</p></li>
<li><p><strong>fsp_load_indices</strong> (<em>list</em>) – indices of load FSPs (optional, but at least one of fsp_load_indices or fsp_dg_indices should be non-empty). Default=[].</p></li>
<li><p><strong>fsp_dg_indices</strong> (<em>list</em>) – indices of DG FSPs (optional, but at least one of fsp_load_indices or fsp_dg_indices should be non-empty). Default=[].</p></li>
<li><p><strong>scenario_type</strong> (<em>dict</em>) – Scenario for network settings (e.g.CS=closed switches, only used if net is None). Default={“name”: ‘CS’, “no.”: 0}.</p></li>
<li><p><strong>flex_shape</strong> (<em>dict</em>) – Shape of flexibility from service providers. To change the shape for different resources,
or change the shape for all resources, plase create a new function in place of
conv_profile_creation(). Currently supported shapes: “Smax”: resource outputs cannot exceed the
maximum apparent power (semi-oval shape), “PQmax”: resource active and reactive power
individually cannot exceed maximum apparent power (rectangle shape). Default=”Smax”.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>Flexibility area plot and csv of dataframe are stored locally. The function returns nothing.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>None</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py">
<span class="sig-prename descclassname"><span class="pre">FA_Estimator.</span></span><span class="sig-name descname"><span class="pre">tc_plus_adapt</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">net</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">net_name</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">'MV</span> <span class="pre">Oberrhein0'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">max_curr_per</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">100</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">max_volt_pu</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">1.05</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">min_volt_pu</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">0.95</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">non_linear_fsps</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">list</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">[]</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fsp_load_indices</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">list</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">[]</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fsp_dg_indices</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">list</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">[]</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">scenario_type</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">dict</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">{'name':</span> <span class="pre">'CS',</span> <span class="pre">'no.':</span> <span class="pre">0}</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>Package Function to run the TensorConvolution+ algorithm and adapt from stored tensors for previous OCs.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>net</strong> (<em>pp.networks</em>) – Pandapower network (optional). Default=None.</p></li>
<li><p><strong>net_name</strong> (<em>str</em>) – Network name (optional, only used if network is not given). Default=’MV Oberrhein0’.</p></li>
<li><p><strong>dp</strong> (<em>float</em>) – step size in active power (optional). Default=0.05.</p></li>
<li><p><strong>dq</strong> (<em>float</em>) – step size in reactive power (optional). Default=0.05.</p></li>
<li><p><strong>max_curr_per</strong> (<em>int</em>) – network maximum current constraint (optional). Default=100.</p></li>
<li><p><strong>max_volt_pu</strong> (<em>float</em>) – network maximum voltage constraint (optional). Default=1.05.</p></li>
<li><p><strong>min_volt_pu</strong> (<em>float</em>) – network minimum voltage constraint (optional). Default=0.95.</p></li>
<li><p><strong>non_linear_fsps</strong> (<em>list</em>) – not tested for this modality. Kept as input for future expansion. Default=[].</p></li>
<li><p><strong>fsp_load_indices</strong> (<em>list</em>) – indices of load FSPs (must be the exact same as the scenario it adapts from). Default=[].</p></li>
<li><p><strong>fsp_dg_indices</strong> (<em>list</em>) – indices of DG FSPs (must be the exact same as the scenario it adapts from). Default=[].</p></li>
<li><p><strong>scenario_type</strong> (<em>dict</em>) – Scenario for network settings (e.g.CS=closed switches, only used if net is None). Default={“name”: ‘CS’, “no.”: 0}.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>Flexibility area plot and csv of dataframe are stored locally. The function returns nothing.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>None</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py">
<span class="sig-prename descclassname"><span class="pre">FA_Estimator.</span></span><span class="sig-name descname"><span class="pre">tc_plus_merge</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">net</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">net_name</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">'MV</span> <span class="pre">Oberrhein0'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dp</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">0.05</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dq</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">0.05</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">max_curr_per</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">100</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">max_volt_pu</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">1.05</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">min_volt_pu</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">0.95</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">l_sens</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">v_sens</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">0.001</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fsp_load_indices</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">list</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">[]</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fsp_dg_indices</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">list</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">[]</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">scenario_type</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">dict</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">{'name':</span> <span class="pre">'CS',</span> <span class="pre">'no.':</span> <span class="pre">0}</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">flex_shape</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">'Smax'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">max_fsps</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">-1</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>Package Function to run the TensorConvolution+ algorithm but merge FSPs for network components that are
sensitive to more than ‘max_fsps’ FSPs (to solve possible memory issues but possibly reduce accuracy).</p>
<blockquote>
<div><dl class="field-list simple">
<dt class="field-odd">param net<span class="colon">:</span></dt>
<dd class="field-odd"><p>Pandapower network (optional). Default=None.</p>
</dd>
<dt class="field-even">type net<span class="colon">:</span></dt>
<dd class="field-even"><p>pp.networks</p>
</dd>
<dt class="field-odd">param net_name<span class="colon">:</span></dt>
<dd class="field-odd"><p>Network name (optional, only used if network is not given). Default=’MV Oberrhein0’.</p>
</dd>
<dt class="field-even">type net_name<span class="colon">:</span></dt>
<dd class="field-even"><p>str</p>
</dd>
<dt class="field-odd">param dp<span class="colon">:</span></dt>
<dd class="field-odd"><p>step size in active power (optional). Default=0.05.</p>
</dd>
<dt class="field-even">type dp<span class="colon">:</span></dt>
<dd class="field-even"><p>float</p>
</dd>
<dt class="field-odd">param dq<span class="colon">:</span></dt>
<dd class="field-odd"><p>step size in reactive power (optional). Default=0.05.</p>
</dd>
<dt class="field-even">type dq<span class="colon">:</span></dt>
<dd class="field-even"><p>float</p>
</dd>
<dt class="field-odd">param max_curr_per<span class="colon">:</span></dt>
<dd class="field-odd"><p>network maximum current constraint (optional). Default=100.</p>
</dd>
<dt class="field-even">type max_curr_per<span class="colon">:</span></dt>
<dd class="field-even"><p>int</p>
</dd>
<dt class="field-odd">param max_volt_pu<span class="colon">:</span></dt>
<dd class="field-odd"><p>network maximum voltage constraint (optional). Default=1.05.</p>
</dd>
<dt class="field-even">type max_volt_pu<span class="colon">:</span></dt>
<dd class="field-even"><p>float</p>
</dd>
<dt class="field-odd">param min_volt_pu<span class="colon">:</span></dt>
<dd class="field-odd"><p>network minimum voltage constraint (optional). Default=0.95.</p>
</dd>
<dt class="field-even">type min_volt_pu<span class="colon">:</span></dt>
<dd class="field-even"><p>float</p>
</dd>
<dt class="field-odd">param l_sens<span class="colon">:</span></dt>
<dd class="field-odd"><p>loading sensitivity threshold (optional). Default=1.</p>
</dd>
<dt class="field-even">type l_sens<span class="colon">:</span></dt>
<dd class="field-even"><p>float</p>
</dd>
<dt class="field-odd">param v_sens<span class="colon">:</span></dt>
<dd class="field-odd"><p>voltage sensitivity threshold (optional). Default=0.001.</p>
</dd>
<dt class="field-even">type v_sens<span class="colon">:</span></dt>
<dd class="field-even"><p>float</p>
</dd>
<dt class="field-odd">param fsp_load_indices<span class="colon">:</span></dt>
<dd class="field-odd"><p>indices of load FSPs (optional, but at least one of fsp_load_indices or fsp_dg_indices should be non-empty). Default=[].</p>
</dd>
<dt class="field-even">type fsp_load_indices<span class="colon">:</span></dt>
<dd class="field-even"><p>list</p>
</dd>
<dt class="field-odd">param fsp_dg_indices<span class="colon">:</span></dt>
<dd class="field-odd"><p>indices of DG FSPs (optional, but at least one of fsp_load_indices or fsp_dg_indices should be non-empty). Default=[].</p>
</dd>
<dt class="field-even">type fsp_dg_indices<span class="colon">:</span></dt>
<dd class="field-even"><p>list</p>
</dd>
<dt class="field-odd">param scenario_type<span class="colon">:</span></dt>
<dd class="field-odd"><p>Scenario for network settings (e.g.CS=closed switches, only used if net is None). Default={“name”: ‘CS’, “no.”: 0}.</p>
</dd>
<dt class="field-even">type scenario_type<span class="colon">:</span></dt>
<dd class="field-even"><p>dict</p>
</dd>
<dt class="field-odd">param flex_shape<span class="colon">:</span></dt>
<dd class="field-odd"><p>Shape of flexibility from service providers. To change the shape for different resources,
or change the shape for all resources, plase create a new function in place of
conv_profile_creation(). Currently supported shapes: “Smax”: resource outputs cannot exceed the
maximum apparent power (semi-oval shape), “PQmax”: resource active and reactive power
individually cannot exceed maximum apparent power (rectangle shape). Default=”Smax”.</p>
</dd>
<dt class="field-even">type flex_shape<span class="colon">:</span></dt>
<dd class="field-even"><p>dict</p>
</dd>
<dt class="field-odd">param max_fsps<span class="colon">:</span></dt>
<dd class="field-odd"><p>Number of FSPs to allow for each component’s sensitivity before merging. Default=-1 would take maximum FSPs as the input FSPs -1 (merging at most 2 FSPs into 1).</p>
</dd>
<dt class="field-even">type max_fsps<span class="colon">:</span></dt>
<dd class="field-even"><p>int</p>
</dd>
<dt class="field-odd">return<span class="colon">:</span></dt>
<dd class="field-odd"><p>Flexibility area plot and csv of dataframe are stored locally. The function returns nothing.</p>
</dd>
<dt class="field-even">rtype<span class="colon">:</span></dt>
<dd class="field-even"><p>None</p>
</dd>
</dl>
</div></blockquote>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py">
<span class="sig-prename descclassname"><span class="pre">FA_Estimator.</span></span><span class="sig-name descname"><span class="pre">tc_plus_save_tensors</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">net</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">net_name</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">'MV</span> <span class="pre">Oberrhein0'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dp</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">0.05</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dq</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">0.05</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">max_curr_per</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">100</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">max_volt_pu</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">1.05</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">min_volt_pu</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">0.95</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">l_sens</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">v_sens</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">0.001</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">non_linear_fsps</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">list</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">[]</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fsp_load_indices</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">list</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">[]</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fsp_dg_indices</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">list</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">[]</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">scenario_type</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">dict</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">{'name':</span> <span class="pre">'CS',</span> <span class="pre">'no.':</span> <span class="pre">0}</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">flex_shape</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">'Smax'</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>Package Function to run the TensorConvolution+ algorithm and save the tensors during estimation.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>net</strong> (<em>pp.networks</em>) – Pandapower network (optional). Default=None.</p></li>
<li><p><strong>net_name</strong> (<em>str</em>) – Network name (optional, only used if network is not given). Default=’MV Oberrhein0’.</p></li>
<li><p><strong>dp</strong> (<em>float</em>) – step size in active power (optional). Default=0.05.</p></li>
<li><p><strong>dq</strong> (<em>float</em>) – step size in reactive power (optional). Default=0.05.</p></li>
<li><p><strong>max_curr_per</strong> (<em>int</em>) – network maximum current constraint (optional). Default=100.</p></li>
<li><p><strong>max_volt_pu</strong> (<em>float</em>) – network maximum voltage constraint (optional). Default=1.05.</p></li>
<li><p><strong>min_volt_pu</strong> (<em>float</em>) – network minimum voltage constraint (optional). Default=0.95.</p></li>
<li><p><strong>l_sens</strong> (<em>float</em>) – loading sensitivity threshold (optional). Default=1.</p></li>
<li><p><strong>v_sens</strong> (<em>float</em>) – voltage sensitivity threshold (optional). Default=0.001.</p></li>
<li><p><strong>non_linear_fsps</strong> (<em>list</em>) – indices of non linear_fsps, offering 2 setpoints (optional). Default=[].</p></li>
<li><p><strong>fsp_load_indices</strong> (<em>list</em>) – indices of load FSPs (optional, but at least one of fsp_load_indices or fsp_dg_indices should be non-empty). Default=[].</p></li>
<li><p><strong>fsp_dg_indices</strong> (<em>list</em>) – indices of DG FSPs (optional, but at least one of fsp_load_indices or fsp_dg_indices should be non-empty). Default=[].</p></li>
<li><p><strong>scenario_type</strong> (<em>dict</em>) – Scenario for network settings (e.g.CS=closed switches, only used if net is None). Default={“name”: ‘CS’, “no.”: 0}.</p></li>
<li><p><strong>flex_shape</strong> (<em>dict</em>) – Shape of flexibility from service providers. To change the shape for different resources,
or change the shape for all resources, plase create a new function in place of
conv_profile_creation(). Currently supported shapes: “Smax”: resource outputs cannot exceed the
maximum apparent power (semi-oval shape), “PQmax”: resource active and reactive power
individually cannot exceed maximum apparent power (rectangle shape). Default=”Smax”.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>Flexibility area plot and csv of dataframe are stored locally. The function returns nothing.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>None</p>
</dd>
</dl>
</dd></dl>

</section>
<section id="convolution-simulations">
<h3>Convolution Simulations<a class="headerlink" href="#convolution-simulations" title="Link to this heading"></a></h3>
<p>This Python Script includes all functions applying tensor convolutions to estimate flexibility areas.</p>
<dl class="py function">
<dt class="sig sig-object py">
<span class="sig-prename descclassname"><span class="pre">conv_simulations.</span></span><span class="sig-name descname"><span class="pre">adaptable_new_op</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">net</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">init_pcc_pq</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">minmax_v</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">[0.95,</span> <span class="pre">1.05]</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">max_l</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">100</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>Calculate FA using previous FA estimation for different operating conditions.
This function calculates the flexibility area (FA) using previous FA estimation for different
operating conditions.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>net</strong> (<em>pandapower.network</em>) – The distribution network.</p></li>
<li><p><strong>init_pcc_pq</strong> (<em>tuple</em>) – Initial values for power (P) and reactive power (Q) of the PCC.</p></li>
<li><p><strong>minmax_v</strong> (<em>list</em><em>[</em><em>float</em><em>, </em><em>float</em><em>]</em>) – The scenario network voltage constraints.</p></li>
<li><p><strong>max_l</strong> (<em>float</em>) – The scenario network loading constraints.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>The flexibility area (FA), the uncertainty including flexibility area, the reachable area,
the binary flexibility area, the p index of initial operating point, the q index of initial
operating point, a string on the simulation duration, extra info depending on scenario.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>pandas.Dataframe, pandas.Dataframe, pandas.Dataframe, pandas.Dataframe, float, float, str,
pandas.Dataframe</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py">
<span class="sig-prename descclassname"><span class="pre">conv_simulations.</span></span><span class="sig-name descname"><span class="pre">combine_shapes</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">shapes</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">pq_steps</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>Combine the feasible regions for different discontinuous area setpoints.
This function combines the feasible regions for different discontinuous area setpoints.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>shapes</strong> (<em>list</em><em>[</em><em>str</em><em>]</em>) – The flexibility regions for different setpoints of the non-linear FSP.</p></li>
<li><p><strong>pq_steps</strong> (<em>numpy.ndarray/list</em>) – Non linear FSPs P,Q setpoints.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>The combined flexibility region.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>numpy.array</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py">
<span class="sig-prename descclassname"><span class="pre">conv_simulations.</span></span><span class="sig-name descname"><span class="pre">combine_shapes_const_flex</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">shapes</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">pq_steps</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">flex</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>Combine the feasible regions for different discontinuous area setpoints, in case where no network
constraint can be reached.
This function combines the feasible regions for different discontinuous area setpoints, in case where no
network constraint can be reached.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>shapes</strong> (<em>list</em><em>[</em><em>str</em><em>]</em>) – The flexibility regions for different setpoints of the non-linear FSP.</p></li>
<li><p><strong>pq_steps</strong> (<em>numpy.ndarray/list</em>) – Non linear FSPs P,Q setpoints.</p></li>
<li><p><strong>flex</strong> (<em>numpy.ndarray/list</em>) – Flexibility region linear FSPs.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>The combined flexibility region.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>numpy.array</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py">
<span class="sig-prename descclassname"><span class="pre">conv_simulations.</span></span><span class="sig-name descname"><span class="pre">create_mat_dict_incl_delta</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">result_dict</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dp</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dq</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">non_lin_fsp</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">init_pq</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>Create matrices, dictionaries, and axes from a result dictionary including delta values.
This function takes a dictionary of results and generates matrices, dictionaries, axes for
power (P) and reactive power (Q) with and without delta values. It also includes non-linear
power systems for the given keys.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>result_dict</strong> (<em>dict</em>) – A dictionary containing result data.</p></li>
<li><p><strong>dp</strong> (<em>float</em>) – The power resolution (dp) for matrix generation.</p></li>
<li><p><strong>dq</strong> (<em>float</em>) – The reactive power resolution (dq) for matrix generation.</p></li>
<li><p><strong>non_lin_fsp</strong> (<em>list</em>) – A list of keys corresponding to non-linear power systems.</p></li>
<li><p><strong>init_pq</strong> (<em>tuple</em>) – Initial values for power (P) and reactive power (Q).</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>The resulting power matrix (PQ), dictionaries, axes for power (P) and
reactive power (Q) without delta, axes for power (P) and reactive power (Q) with delta,
and an uncertainty matrix for feasibility.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>numpy.ndarray, dict, list, list, list, list, dict</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py">
<span class="sig-prename descclassname"><span class="pre">conv_simulations.</span></span><span class="sig-name descname"><span class="pre">create_mat_dict_order</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">result_dict</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dp</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dq</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">small_fsps</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">[]</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>Create matrices and dictionaries from a result dictionary using PyTorch tensors.
This function takes a dictionary of results and generates matrices and dictionaries
based on the provided dp and dq values. It performs convolution operations on selected
matrices and returns the resulting matrices, dictionaries, axes for power (P) and
reactive power (Q), and the order of keys used in the convolution.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>result_dict</strong> (<em>dict</em>) – A dictionary containing result data.</p></li>
<li><p><strong>dp</strong> (<em>float</em>) – The power resolution (dp) for matrix generation.</p></li>
<li><p><strong>dq</strong> (<em>float</em>) – The reactive power resolution (dq) for matrix generation.</p></li>
<li><p><strong>small_fsps</strong> (<em>list</em><em>[</em><em>str</em><em>]</em>) – A list of keys corresponding to small flexible power systems.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>The resulting power matrix (PQ), dictionaries, axes for
power (P) and reactive power (Q), and the order of keys used in convolution.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>numpy.ndarray, dict, list, list, list</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py">
<span class="sig-prename descclassname"><span class="pre">conv_simulations.</span></span><span class="sig-name descname"><span class="pre">create_mat_dict_tensor</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">result_dict</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dp</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dq</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">small_fsps</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">[]</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>Create matrices and dictionaries from a result dictionary using PyTorch tensors.
This function takes a dictionary of results and generates matrices and dictionaries
based on the provided dp and dq values. It performs convolution operations on selected
matrices and returns the resulting matrices, dictionaries, and axes for power (P) and
reactive power (Q). Additionally, it calculates the uncertainty factor (unc_fa).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>result_dict</strong> (<em>dict</em>) – A dictionary containing result data.</p></li>
<li><p><strong>dp</strong> (<em>float</em>) – The power resolution (dp) for matrix generation.</p></li>
<li><p><strong>dq</strong> (<em>float</em>) – The reactive power resolution (dq) for matrix generation.</p></li>
<li><p><strong>small_fsps</strong> (<em>list</em><em>[</em><em>str</em><em>]</em>) – A list of keys corresponding to small flexible power systems.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>The resulting power matrix (PQ), dictionaries, axes for
power (P) and reactive power (Q), and the uncertainty factor matrix (unc_fa).</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>numpy.ndarray, dict, list, list, numpy.ndarray</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py">
<span class="sig-prename descclassname"><span class="pre">conv_simulations.</span></span><span class="sig-name descname"><span class="pre">create_mat_dict_tensorv2</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">result_dict</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dp</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dq</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>Create matrices and dictionaries from a result dictionary using PyTorch tensors.
This function takes a dictionary of results and generates matrices, dictionaries, axes for
power (P) and reactive power (Q), and initialization IDs based on the provided dp and dq values.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>result_dict</strong> (<em>dict</em>) – A dictionary containing result data.</p></li>
<li><p><strong>dp</strong> (<em>float</em>) – The power resolution (dp) for matrix generation.</p></li>
<li><p><strong>dq</strong> (<em>float</em>) – The reactive power resolution (dq) for matrix generation.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>The resulting power matrix (PQ), dictionaries, axes for power (P) and
reactive power (Q), the initialization IDs, and an uncertainty matrix for feasibility.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>numpy.ndarray, dict, list, list, dict</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py">
<span class="sig-prename descclassname"><span class="pre">conv_simulations.</span></span><span class="sig-name descname"><span class="pre">create_multi_small_fsp_fas</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">prof_dict</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dp</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dq</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">init_fsp_pq</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>Create a multi-flexibility area (MFA) by combining small feasible space profiles.
This function combines multiple small feasible space profiles into a single
multi-flexibility area (MFA) using convolution.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>prof_dict</strong> (<em>dict</em>) – A dictionary containing small feasible space profiles.</p></li>
<li><p><strong>dp</strong> (<em>float</em>) – The step size for active power (P).</p></li>
<li><p><strong>dq</strong> (<em>float</em>) – The step size for reactive power (Q).</p></li>
<li><p><strong>init_fsp_pq</strong> (<em>dict</em>) – Initial values for active power (P) and reactive power (Q) for each profile.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>The multi-flexibility area (MFA) obtained by combining small feasible space profiles.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>numpy.ndarray</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py">
<span class="sig-prename descclassname"><span class="pre">conv_simulations.</span></span><span class="sig-name descname"><span class="pre">df_to_mat_tensor_scaled_and_init</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">df</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dp</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dq</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>Take dataframes of power flow results and create matrices of feasible regions, sensitivities
for tensor convolutions.
This function takes dataframes of power flow results and creates matrices of feasible regions, sensitivities
for tensor convolutions.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>df</strong> (<em>pandas.dataframe</em>) – Dataframe with power flow results.</p></li>
<li><p><strong>dp</strong> (<em>float</em>) – Resolution in dp.</p></li>
<li><p><strong>dq</strong> (<em>float</em>) – Resolution in dq.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>The result dictionary, p axis and q axis.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>dict, np.array, np.array</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py">
<span class="sig-prename descclassname"><span class="pre">conv_simulations.</span></span><span class="sig-name descname"><span class="pre">df_to_mat_tensor_torch</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">df</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dp</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dq</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>Take dataframes of power flow results and create matrices of feasible regions, sensitivities
for tensor convolutions.
This function takes dataframes of power flow results and creates matrices of feasible regions, sensitivities
for tensor convolutions.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>df</strong> (<em>pandas.dataframe</em>) – Dataframe with power flow results.</p></li>
<li><p><strong>dp</strong> (<em>float</em>) – Resolution in dp.</p></li>
<li><p><strong>dq</strong> (<em>float</em>) – Resolution in dq.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>The result dictionary, p axis and q axis.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>dict, np.array, np.array</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py">
<span class="sig-prename descclassname"><span class="pre">conv_simulations.</span></span><span class="sig-name descname"><span class="pre">df_to_mat_tensor_torchv2</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">df</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dp</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dq</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>Take dataframes of power flow results and create matrices of feasible regions, sensitivities
for tensor convolutions.
This function takes dataframes of power flow results and creates matrices of feasible regions, sensitivities
for tensor convolutions.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>df</strong> (<em>pandas.dataframe</em>) – Dataframe with power flow results.</p></li>
<li><p><strong>dp</strong> (<em>float</em>) – Resolution in dp.</p></li>
<li><p><strong>dq</strong> (<em>float</em>) – Resolution in dq.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>The result dictionary, p axis and q axis.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>dict, np.array, np.array</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py">
<span class="sig-prename descclassname"><span class="pre">conv_simulations.</span></span><span class="sig-name descname"><span class="pre">enhance_multi_big_fa</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">fa</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">times</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">5.0</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>Enhance the size of a multi-flexibility area (MFA) using bilinear interpolation.
This function enhances the size of a multi-flexibility area (MFA) by a specified factor using bilinear
interpolation.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>fa</strong> (<em>numpy.ndarray</em>) – The multi-flexibility area (MFA) to be enhanced.</p></li>
<li><p><strong>times</strong> (<em>float</em><em>, </em><em>optional</em>) – The enhancement factor (default is 5.0).</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>The enhanced multi-flexibility area (MFA).</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>numpy.ndarray</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py">
<span class="sig-prename descclassname"><span class="pre">conv_simulations.</span></span><span class="sig-name descname"><span class="pre">find_value_close2list</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">lst</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">voi</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>Find the index and closest value in a list to a specified value.
This function searches for the index and value in the input list <cite>lst</cite> that is closest to the specified value <cite>voi</cite>.
It iterates through the list and calculates the absolute difference between each element and <cite>voi</cite> to find the
closest match.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>lst</strong> (<em>list</em><em>[</em><em>float</em><em>]</em>) – The list to search for the closest value.</p></li>
<li><p><strong>voi</strong> (<em>float</em>) – The value to find the closest match for.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>The index of the closest value in the list and the closest value itself.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>int, float</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py">
<span class="sig-prename descclassname"><span class="pre">conv_simulations.</span></span><span class="sig-name descname"><span class="pre">get_bus_line_and_trafo_names</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">net</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>Get names of buses, lines, and transformers in a power distribution network.
This function extracts and returns the names of buses, lines, and transformers from the provided
<cite>pandapowerNet</cite> object.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>net</strong> (<em>pandapowerNet</em>) – A pandapowerNet object representing a power distribution network.</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>A list of bus names, line names, and transformer names.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>list[str], list[str], list[str]</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py">
<span class="sig-prename descclassname"><span class="pre">conv_simulations.</span></span><span class="sig-name descname"><span class="pre">get_delta</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">df</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dp</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dq</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">init_pq</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>Take dataframes of power flow results and create matrices of feasible regions, sensitivities
for tensor convolutions, for non-linear FSPS.
This function takes dataframes of power flow results and creates matrices of feasible regions, sensitivities
for tensor convolutions, for non-linear FSPS.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>df</strong> (<em>pandas.dataframe</em>) – Dataframe with power flow results.</p></li>
<li><p><strong>dp</strong> (<em>float</em>) – Resolution in dp.</p></li>
<li><p><strong>dq</strong> (<em>float</em>) – Resolution in dq.</p></li>
<li><p><strong>init_pq</strong> (<em>list</em><em>[</em><em>float</em><em>, </em><em>float</em><em>]</em>) – Initial P,Q values.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>The result list, p axis, q axis, and binary matrix.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>list, np.array, np.array, np.array</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py">
<span class="sig-prename descclassname"><span class="pre">conv_simulations.</span></span><span class="sig-name descname"><span class="pre">get_init_net_state</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">net</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>Calculate initial network component voltage and loading values.
This function calculates the initial network component voltage and loading values.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>Two dictionaries containing the initial voltage magnitude for buses,
and loading for lines/transformers.</p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p>dict, dict</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py">
<span class="sig-prename descclassname"><span class="pre">conv_simulations.</span></span><span class="sig-name descname"><span class="pre">get_multi_conv_key_adapting_new_op</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">comp</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">bus_nm</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">init_v</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">init_load</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">min_v</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">max_v</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>Calculate flexibility region for component from sensitive FSPs
using previous FA estimation for different operating conditions.
This function calculates the flexibility region for component from sensitive FSPs
using previous FA estimation for different operating conditions.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>comp</strong> (<em>str</em>) – The distribution network component name (e.g.bus 1).</p></li>
<li><p><strong>bus_nm</strong> (<em>list</em><em>[</em><em>str</em><em>]</em>) – Distribution network bus names.</p></li>
<li><p><strong>init_v</strong> (<em>numpy.ndarray/list</em>) – Initial voltage magnitudes of network buses.</p></li>
<li><p><strong>init_load</strong> (<em>numpy.ndarray/list</em>) – Initial loading of network lines/transformers.</p></li>
<li><p><strong>min_v</strong> (<em>float</em>) – The scenario network minimum voltage constraints.</p></li>
<li><p><strong>max_v</strong> (<em>float</em>) – The scenario network maximum voltage constraints.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>The flexibility region from FSPs in which the component is sensitive.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>numpy.array</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py">
<span class="sig-prename descclassname"><span class="pre">conv_simulations.</span></span><span class="sig-name descname"><span class="pre">get_multi_conv_key_saving</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">fsps_of_comp</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mat_dicts</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">comp</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">bus_nm</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">init_v</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">init_load</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">max_v</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1.05</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">min_v</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.95</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>Calculate flexibility region for component from sensitive FSPs, perform TTD on the tensors and save them
locally.</p>
<p>This function calculates the flexibility region for component from sensitive FSPs, perform TTD on the
tensors and save them locally.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>fsps_of_comp</strong> (<em>list</em><em>[</em><em>str</em><em>]</em>) – The FSPs in which the component is sensitive.</p></li>
<li><p><strong>mat_dicts</strong> (<em>dict</em>) – The dictionary of power flow sensitivities from each FSP per component.</p></li>
<li><p><strong>comp</strong> (<em>str</em>) – The distribution network component name (e.g.bus 1).</p></li>
<li><p><strong>bus_nm</strong> (<em>list</em><em>[</em><em>str</em><em>]</em>) – Distribution network bus names.</p></li>
<li><p><strong>init_v</strong> (<em>numpy.ndarray/list</em>) – Initial voltage magnitudes of network buses.</p></li>
<li><p><strong>init_load</strong> (<em>numpy.ndarray/list</em>) – Initial loading of network lines/transformers.</p></li>
<li><p><strong>min_v</strong> (<em>float</em>) – The scenario network minimum voltage constraints.</p></li>
<li><p><strong>max_v</strong> (<em>float</em>) – The scenario network maximum voltage constraints.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>The flexibility region from FSPs in which the component is sensitive.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>numpy.array</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py">
<span class="sig-prename descclassname"><span class="pre">conv_simulations.</span></span><span class="sig-name descname"><span class="pre">get_multi_conv_key_with_delta</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">fsps_of_comp</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mat_dicts</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">comp</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">bus_nm</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">init_v</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">init_load</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">comp_non_lin_fsp</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">pq_steps</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">max_v</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1.1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">min_v</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.9</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>Calculate flexibility region for component from sensitive FSPs, while having discrete FSPs.
This function calculates the flexibility region for component from sensitive FSPs, while having discrete FSPs.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>fsps_of_comp</strong> (<em>list</em><em>[</em><em>str</em><em>]</em>) – The FSPs in which the component is sensitive.</p></li>
<li><p><strong>mat_dicts</strong> (<em>dict</em>) – The dictionary of power flow sensitivities from each FSP per component.</p></li>
<li><p><strong>comp</strong> (<em>str</em>) – The distribution network component name (e.g.bus 1).</p></li>
<li><p><strong>bus_nm</strong> (<em>list</em><em>[</em><em>str</em><em>]</em>) – Distribution network bus names.</p></li>
<li><p><strong>init_v</strong> (<em>numpy.ndarray/list</em>) – Initial voltage magnitudes of network buses.</p></li>
<li><p><strong>init_load</strong> (<em>numpy.ndarray/list</em>) – Initial loading of network lines/transformers.</p></li>
<li><p><strong>comp_non_lin_fsp</strong> (<em>list</em>) – Non linear FSPs for which the component is sensitive.</p></li>
<li><p><strong>pq_steps</strong> (<em>numpy.ndarray/list</em>) – Non linear FSPs P,Q setpoints.</p></li>
<li><p><strong>min_v</strong> (<em>float</em>) – The scenario network minimum voltage constraints.</p></li>
<li><p><strong>max_v</strong> (<em>float</em>) – The scenario network maximum voltage constraints.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>The flexibility region from FSPs in which the component is sensitive.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>numpy.array</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py">
<span class="sig-prename descclassname"><span class="pre">conv_simulations.</span></span><span class="sig-name descname"><span class="pre">get_multi_conv_torch</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">fsps_of_comp</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mat_dicts</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">comp</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">bus_nm</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">init_v</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">init_load</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">max_v</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1.05</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">min_v</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.95</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>Calculate flexibility region for component from sensitive FSPs.
This function calculates the flexibility region for component from sensitive FSPs.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>fsps_of_comp</strong> (<em>list</em><em>[</em><em>str</em><em>]</em>) – The FSPs in which the component is sensitive.</p></li>
<li><p><strong>mat_dicts</strong> (<em>dict</em>) – The dictionary of power flow sensitivities from each FSP per component.</p></li>
<li><p><strong>comp</strong> (<em>str</em>) – The distribution network component name (e.g.bus 1).</p></li>
<li><p><strong>bus_nm</strong> (<em>list</em><em>[</em><em>str</em><em>]</em>) – Distribution network bus names.</p></li>
<li><p><strong>init_v</strong> (<em>numpy.ndarray/list</em>) – Initial voltage magnitudes of network buses.</p></li>
<li><p><strong>init_load</strong> (<em>numpy.ndarray/list</em>) – Initial loading of network lines/transformers.</p></li>
<li><p><strong>min_v</strong> (<em>float</em>) – The scenario network minimum voltage constraints.</p></li>
<li><p><strong>max_v</strong> (<em>float</em>) – The scenario network maximum voltage constraints.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>The flexibility region from FSPs in which the component is sensitive.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>numpy.array</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py">
<span class="sig-prename descclassname"><span class="pre">conv_simulations.</span></span><span class="sig-name descname"><span class="pre">get_multi_conv_torch_split</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">fsps_of_comp</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mat_dicts</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">comp</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">bus_nm</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">init_v</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">init_load</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sim_dict</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">init_ids</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">max_v</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1.05</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">min_v</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.95</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">no_max</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">5</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>Calculate flexibility region for component from sensitive FSPs, but merge FSPs until maximum fsps are
no_max-1.
This function calculates the flexibility region for component from sensitive FSPs, but merge FSPs until
maximum fsps are no_max-1.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>fsps_of_comp</strong> (<em>list</em><em>[</em><em>str</em><em>]</em>) – The FSPs in which the component is sensitive.</p></li>
<li><p><strong>mat_dicts</strong> (<em>dict</em>) – The dictionary of power flow sensitivities from each FSP per component.</p></li>
<li><p><strong>comp</strong> (<em>str</em>) – The distribution network component name (e.g.bus 1).</p></li>
<li><p><strong>bus_nm</strong> (<em>list</em><em>[</em><em>str</em><em>]</em>) – Distribution network bus names.</p></li>
<li><p><strong>init_v</strong> (<em>numpy.ndarray/list</em>) – Initial voltage magnitudes of network buses.</p></li>
<li><p><strong>init_load</strong> (<em>numpy.ndarray/list</em>) – Initial loading of network lines/transformers.</p></li>
<li><p><strong>sim_dict</strong> (<em>dictionary</em>) – Estimated electrical dinstance per FSP pair.</p></li>
<li><p><strong>init_ids</strong> (<em>dictionary</em>) – Initial P,Q values per FSP.</p></li>
<li><p><strong>min_v</strong> (<em>float</em>) – The scenario network minimum voltage constraints.</p></li>
<li><p><strong>max_v</strong> (<em>float</em>) – The scenario network maximum voltage constraints.</p></li>
<li><p><strong>no_max</strong> (<em>int</em>) – The maximum+1 FSPs that can be accounted for in the tensors.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>The flexibility region from FSPs in which the component is sensitive.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>numpy.array</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py">
<span class="sig-prename descclassname"><span class="pre">conv_simulations.</span></span><span class="sig-name descname"><span class="pre">get_multi_result_for_0_effective</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">non_effective_fsps</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mat_dicts</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>Estimate flexibility area if no component can reach its constraint.
This function estimated flexibility area, in case where no
network constraint can be reached.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>non_effective_fsps</strong> (<em>list</em><em>[</em><em>str</em><em>]</em>) – The FSP names.</p></li>
<li><p><strong>mat_dicts</strong> (<em>dict</em>) – The power flow results.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>The flexibility area.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>numpy.array</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py">
<span class="sig-prename descclassname"><span class="pre">conv_simulations.</span></span><span class="sig-name descname"><span class="pre">get_multi_uncertain_fa</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">pq_mat</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">large_fa</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">small_prof_dict</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dp</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dq</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">init_fsp_pq</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">p_axes</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">q_axes</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>Calculate multiple uncertain feasibility areas from given power matrices.
This function calculates multiple uncertain feasibility areas (UFAs) from the given power matrices.
It uses both small and large feasibility areas to create UFAs and scales them accordingly.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>pq_mat</strong> (<em>numpy.ndarray</em>) – The power matrix representing the feasibility area.</p></li>
<li><p><strong>large_fa</strong> (<em>numpy.ndarray</em>) – The large feasibility area used for enhancement.</p></li>
<li><p><strong>small_prof_dict</strong> (<em>dict</em>) – A dictionary containing small feasibility profiles.</p></li>
<li><p><strong>dp</strong> (<em>float</em>) – The power resolution (dp) for matrix generation.</p></li>
<li><p><strong>dq</strong> (<em>float</em>) – The reactive power resolution (dq) for matrix generation.</p></li>
<li><p><strong>init_fsp_pq</strong> (<em>dict</em>) – Initial values for power (P) and reactive power (Q) for small feasibility profiles.</p></li>
<li><p><strong>p_axes</strong> (<em>numpy.ndarray</em>) – The power (P) axes for matrix generation.</p></li>
<li><p><strong>q_axes</strong> (<em>numpy.ndarray</em>) – The reactive power (Q) axes for matrix generation.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>The scaled uncertain feasibility area (UFA), the scaled safe area, the scaled
uncertain feasibility area with ones, the new power (P) axes for the large feasibility area, and
the new reactive power (Q) axes for the large feasibility area.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>numpy.ndarray, numpy.ndarray, numpy.ndarray, numpy.ndarray, numpy.ndarray</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py">
<span class="sig-prename descclassname"><span class="pre">conv_simulations.</span></span><span class="sig-name descname"><span class="pre">get_new_conv_axes2</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">list_of_rows</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">list_of_columns</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">conv_q_len</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">conv_p_len</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">q</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">p</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>Combine axes per FSP to get the final flexibility area axes.
This function combines axes per FSP to get the final flexibility area axes.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>list_of_rows</strong> (<em>list</em>) – Row axes from all FSPs.</p></li>
<li><p><strong>list_of_columns</strong> (<em>list</em>) – Column axes from all FSPs.</p></li>
<li><p><strong>conv_q_len</strong> (<em>int</em>) – Convolution result (reachability) height length in pixels.</p></li>
<li><p><strong>conv_p_len</strong> (<em>int</em>) – Convolution result (reachability) weight length in pixels.</p></li>
<li><p><strong>q</strong> (<em>float</em>) – The network PCC initial q.</p></li>
<li><p><strong>p</strong> (<em>float</em>) – The network PCC initial p.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>The flexibility area.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>numpy.array</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py">
<span class="sig-prename descclassname"><span class="pre">conv_simulations.</span></span><span class="sig-name descname"><span class="pre">get_non_effective_multi_conv</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">non_effective_fsps</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">effective_conv</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mat_dicts</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>Estimate flexibility area by convolving non-effective fsps with the region from the effective fsps.
This function estimates flexibility area by convolving non-effective fsps with the region
from the effective fsps.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>non_effective_fsps</strong> (<em>list</em><em>[</em><em>str</em><em>]</em>) – The non-effective FSP names.</p></li>
<li><p><strong>effective_conv</strong> (<em>numpy.array</em>) – The effective FSP flexibility area.</p></li>
<li><p><strong>mat_dicts</strong> (<em>dict</em>) – The power flow results.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>The flexibility area.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>numpy.array</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py">
<span class="sig-prename descclassname"><span class="pre">conv_simulations.</span></span><span class="sig-name descname"><span class="pre">get_non_effective_multi_conv_with_delta</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">non_effective_fsps</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">effective_conv</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mat_dicts</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">non_eff_non_lin_fsps</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">pq_steps</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>Estimate flexibility area by convolving non-effective fsps with the region from the effective fsps,
also accounting for non-effective non-linear FSPs.
This function estimates flexibility area by convolving non-effective fsps with the region
from the effective fsps.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>non_effective_fsps</strong> (<em>list</em><em>[</em><em>str</em><em>]</em>) – The non-effective FSP names.</p></li>
<li><p><strong>effective_conv</strong> (<em>numpy.array</em>) – The effective FSP flexibility area.</p></li>
<li><p><strong>mat_dicts</strong> (<em>dict</em>) – The power flow results.</p></li>
<li><p><strong>non_eff_non_lin_fsps</strong> (<em>list</em><em>[</em><em>str</em><em>]</em>) – The non-effective non-linear FSP names.</p></li>
<li><p><strong>pq_steps</strong> (<em>dict</em>) – The P,Q setpoints of the non-effective non-linear FSP names.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>The flexibility area.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>numpy.array</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py">
<span class="sig-prename descclassname"><span class="pre">conv_simulations.</span></span><span class="sig-name descname"><span class="pre">get_result_for_0_effective_with_delta</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">final_flex</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">non_lin_eff_fsp_per_comp</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">non_lin_ineff_fsp_per_comp</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">pq_steps</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">bus_nm</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">init_v</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">init_l</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mat_dicts</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">max_v</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">min_v</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>Estimate flexibility area if no component can reach its constraint, and non-linear FSPs exist.
This function estimated flexibility area, in case where no.
network constraint can be reached.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>final_flex</strong> (<em>numpy.array</em>) – The linear FSP flexibility area.</p></li>
<li><p><strong>non_lin_eff_fsp_per_comp</strong> (<em>dict</em>) – The  non-linear but effective FSP names.</p></li>
<li><p><strong>non_lin_ineff_fsp_per_comp</strong> (<em>dict</em>) – The non-linear non-effective FSP names.</p></li>
<li><p><strong>pq_steps</strong> (<em>dict</em>) – The P,Q setpoints of the non-effective non-linear FSP names.</p></li>
<li><p><strong>bus_nm</strong> (<em>list</em><em>[</em><em>str</em><em>]</em>) – The network bus names.</p></li>
<li><p><strong>init_v</strong> (<em>dict</em>) – The network bus initial voltage magnitudes.</p></li>
<li><p><strong>init_l</strong> (<em>dict</em>) – The network line/transformer initial loading.</p></li>
<li><p><strong>mat_dicts</strong> (<em>dict</em>) – The power flow results.</p></li>
<li><p><strong>max_v</strong> (<em>dict</em>) – The network constraint maximum voltage magnitudes.</p></li>
<li><p><strong>min_v</strong> (<em>dict</em>) – The network constraint minimum voltage magnitudes.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>The flexibility area.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>numpy.array</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py">
<span class="sig-prename descclassname"><span class="pre">conv_simulations.</span></span><span class="sig-name descname"><span class="pre">numpy_tensor_conv_simulations_saving</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">net</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">pq_profiles</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dp</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dq</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">init_pcc_pq</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">small_fsp_prof</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">comp_fsp_v_sens</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.001</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">comp_fsp_l_sens</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">min_max_v</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">[0.95,</span> <span class="pre">1.05]</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">max_l</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">100</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>Calculate FA using Tensors and Convolutions, while saving the tensors (after TTD) to adapt FA
in other operating conditions.
This function calculates the flexibility area (FA) using the TensorConvolution+ algorithm while saving the
tensors (after TTD) to adapt FA in other operating conditions.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>net</strong> (<em>pandapower.network</em>) – The distribution network.</p></li>
<li><p><strong>pq_profiles</strong> (<em>numpy.ndarray/list</em>) – The sampled p,q setpoints for the DG.</p></li>
<li><p><strong>dp</strong> (<em>float</em>) – The power resolution (dp) for matrix generation.</p></li>
<li><p><strong>dq</strong> (<em>float</em>) – The reactive power resolution (dq) for matrix generation.</p></li>
<li><p><strong>init_pcc_pq</strong> (<em>tuple</em>) – Initial values for power (P) and reactive power (Q) of the PCC.</p></li>
<li><p><strong>small_fsp_prof</strong> (<em>numpy.ndarray/list</em>) – The sampled p,q setpoints for the small DG.</p></li>
<li><p><strong>comp_fsp_v_sens</strong> (<em>float</em>) – The scenario voltage sensitivity.</p></li>
<li><p><strong>comp_fsp_l_sens</strong> (<em>float</em>) – The scenario loading sensitivity.</p></li>
<li><p><strong>min_max_v</strong> (<em>list</em><em>[</em><em>float</em><em>, </em><em>float</em><em>]</em>) – The scenario network voltage constraints.</p></li>
<li><p><strong>max_l</strong> (<em>float</em>) – The scenario network loading constraints.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>The flexibility area (FA), the uncertainty including flexibility area, the reachable area,
the binary flexibility area, the p index of initial operating point, the q index of initial
operating point, a string on the simulation duration, extra info depending on scenario.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>pandas.Dataframe, pandas.Dataframe, pandas.Dataframe, pandas.Dataframe, float, float, str,
pandas.Dataframe</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py">
<span class="sig-prename descclassname"><span class="pre">conv_simulations.</span></span><span class="sig-name descname"><span class="pre">numpy_tensor_conv_simulations_with_delta</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">net</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">pq_profiles</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dp</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dq</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">init_pcc_pq</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">small_fsp_prof</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">non_lin_fsp</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">[]</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">comp_fsp_v_sens</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.001</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">comp_fsp_l_sens</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">max_v</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1.1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">min_v</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.9</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">max_l</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">100</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>Calculate FA using Tensors and Convolutions, when at least 1 fsp can only shift in certain setpoints.
This function calculates the flexibility area (FA) using the TensorConvolution+ algorithm.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>net</strong> (<em>pandapower.network</em>) – The distribution network.</p></li>
<li><p><strong>pq_profiles</strong> (<em>numpy.ndarray/list</em>) – The sampled p,q setpoints for the DG.</p></li>
<li><p><strong>dp</strong> (<em>float</em>) – The power resolution (dp) for matrix generation.</p></li>
<li><p><strong>dq</strong> (<em>float</em>) – The reactive power resolution (dq) for matrix generation.</p></li>
<li><p><strong>init_pcc_pq</strong> (<em>tuple</em>) – Initial values for power (P) and reactive power (Q) of the PCC.</p></li>
<li><p><strong>small_fsp_prof</strong> (<em>numpy.ndarray/list</em>) – The sampled p,q setpoints for the small DG.</p></li>
<li><p><strong>non_lin_fsp</strong> (<em>list</em>) – The non linear DG.</p></li>
<li><p><strong>comp_fsp_v_sens</strong> (<em>float</em>) – The scenario voltage sensitivity.</p></li>
<li><p><strong>comp_fsp_l_sens</strong> (<em>float</em>) – The scenario loading sensitivity.</p></li>
<li><p><strong>max_v</strong> (<em>float</em>) – The scenario network maximum voltage constraints.</p></li>
<li><p><strong>min_v</strong> (<em>float</em>) – The scenario network minimum voltage constraints.</p></li>
<li><p><strong>max_l</strong> (<em>float</em>) – The scenario network loading constraints.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>The flexibility area (FA), the uncertainty including flexibility area, the reachable area,
the binary flexibility area, the p index of initial operating point, the q index of initial
operating point, a string on the simulation duration, extra info depending on scenario.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>pandas.Dataframe, pandas.Dataframe, pandas.Dataframe, pandas.Dataframe, float, float, str,
pandas.Dataframe</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py">
<span class="sig-prename descclassname"><span class="pre">conv_simulations.</span></span><span class="sig-name descname"><span class="pre">profiles_to_mat</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">profiles</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dp</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dq</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">init_fsp_pq</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>Take dataframes of power flow results and create matrices of feasible regions.
This function takes dataframes of power flow results and creates matrices of feasible regions.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>profiles</strong> (<em>pandas.dataframe</em>) – Dataframe with power flow results.</p></li>
<li><p><strong>dp</strong> (<em>float</em>) – Resolution in dp.</p></li>
<li><p><strong>dq</strong> (<em>float</em>) – Resolution in dq.</p></li>
<li><p><strong>init_fsp_pq</strong> (<em>list</em><em>[</em><em>float</em><em>, </em><em>float</em><em>]</em>) – Initial P,Q values for FSPs.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>Matrix of shifts sensitivities.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>np.array</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py">
<span class="sig-prename descclassname"><span class="pre">conv_simulations.</span></span><span class="sig-name descname"><span class="pre">reduce_multi_fa_small</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">fa</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">times</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.5</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>Reduce the size of a multi-flexibility area (MFA) using bi-linear interpolation.
This function reduces the size of a multi-flexibility area (MFA) by a specified factor using bi-linear
interpolation.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>fa</strong> (<em>numpy.ndarray</em>) – The multi-flexibility area (MFA) to be reduced.</p></li>
<li><p><strong>times</strong> (<em>float</em><em>, </em><em>optional</em>) – The reduction factor (default is 0.5).</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>The reduced multi-flexibility area (MFA).</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>numpy.ndarray</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py">
<span class="sig-prename descclassname"><span class="pre">conv_simulations.</span></span><span class="sig-name descname"><span class="pre">run_all_tensor_flex_areas</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">net</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">pq_profiles</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">bus_nm</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">line_nm</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">trafo_nm</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">init_v</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">init_load</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>Run power flows for all FSP setpoints given.
This function runs power flows for given FSP setpoints.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>net</strong> (<em>pandapower.network</em>) – Distribution network.</p></li>
<li><p><strong>pq_profiles</strong> (<em>numpy.array/list</em>) – Sapled setpoints per FSP.</p></li>
<li><p><strong>bus_nm</strong> (<em>list</em>) – Network bus names.</p></li>
<li><p><strong>line_nm</strong> (<em>list</em>) – Network line names.</p></li>
<li><p><strong>trafo_nm</strong> (<em>list</em>) – Network transformer names.</p></li>
<li><p><strong>init_v</strong> (<em>dict</em>) – The network initial voltage magnitudes for all buses.</p></li>
<li><p><strong>init_load</strong> (<em>dict</em>) – The network initial loading for all lines and transformers.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>The result dictionary, standard deviation information, and duration.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>dict, dict, float</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py">
<span class="sig-prename descclassname"><span class="pre">conv_simulations.</span></span><span class="sig-name descname"><span class="pre">split_lin_from_non_lin</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">comp_dict</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">non_lin_fsp</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>Split linear from non-linear FSPs.
This function splits linear from non-linear FSPs.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>Two dictionaries containing continuous capabilities FSPs,
and the discrete (only full curtailment) capabilities FSPs.</p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p>dict, dict</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py">
<span class="sig-prename descclassname"><span class="pre">conv_simulations.</span></span><span class="sig-name descname"><span class="pre">torch_tensor_conv_large_simulations</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">net</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">pq_profiles</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dp</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dq</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">init_pcc_pq</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">small_fsp_prof</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dist_dicts</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">comp_fsp_v_sens</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.001</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">comp_fsp_l_sens</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">min_max_v</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">[0.95,</span> <span class="pre">1.05]</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">max_l</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">100</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">no_max</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">5</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>Calculate FA using Tensors and Convolutions, but merge FSPs in components who have no_max or more FSPs
sensitivities, until maximum sensitive FSPs are no_max-1 per component.
This function calculates the flexibility area (FA) using the TensorConvolution+ algorithm.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>net</strong> (<em>pandapower.network</em>) – The distribution network.</p></li>
<li><p><strong>pq_profiles</strong> (<em>numpy.ndarray/list</em>) – The sampled p,q setpoints for the DG.</p></li>
<li><p><strong>dp</strong> (<em>float</em>) – The power resolution (dp) for matrix generation.</p></li>
<li><p><strong>dq</strong> (<em>float</em>) – The reactive power resolution (dq) for matrix generation.</p></li>
<li><p><strong>init_pcc_pq</strong> (<em>tuple</em>) – Initial values for power (P) and reactive power (Q) of the PCC.</p></li>
<li><p><strong>small_fsp_prof</strong> (<em>numpy.ndarray/list</em>) – The sampled p,q setpoints for the small DG.</p></li>
<li><p><strong>dist_dicts</strong> (<em>dict</em>) – The dinstance between each FSP pair.</p></li>
<li><p><strong>comp_fsp_v_sens</strong> (<em>float</em>) – The scenario voltage sensitivity.</p></li>
<li><p><strong>comp_fsp_l_sens</strong> (<em>float</em>) – The scenario loading sensitivity.</p></li>
<li><p><strong>min_max_v</strong> (<em>list</em><em>[</em><em>float</em><em>, </em><em>float</em><em>]</em>) – The scenario network voltage constraints.</p></li>
<li><p><strong>max_l</strong> (<em>float</em>) – The scenario network loading constraints.</p></li>
<li><p><strong>no_max</strong> (<em>int</em>) – The scenario maximum+1 FSPs per component.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>The flexibility area (FA), the uncertainty including flexibility area, the reachable area,
the binary flexibility area, the p index of initial operating point, the q index of initial operating
point, a string on the simulation duration, extra info depending on scenario.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>pandas.Dataframe, pandas.Dataframe, pandas.Dataframe, pandas.Dataframe, float, float, str,
pandas.Dataframe</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py">
<span class="sig-prename descclassname"><span class="pre">conv_simulations.</span></span><span class="sig-name descname"><span class="pre">torch_tensor_conv_simulations</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">net</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">pq_profiles</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dp</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dq</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">init_pcc_pq</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">small_fsp_prof</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">comp_fsp_v_sens</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.001</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">comp_fsp_l_sens</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">min_max_v</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">[0.95,</span> <span class="pre">1.05]</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">max_l</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">100</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>Calculate FA using Tensors and Convolutions.
This function calculates the flexibility area (FA) using the TensorConvolution+ algorithm.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>net</strong> (<em>pandapower.network</em>) – The distribution network.</p></li>
<li><p><strong>pq_profiles</strong> (<em>numpy.ndarray/list</em>) – The sampled p,q setpoints for the DG.</p></li>
<li><p><strong>dp</strong> (<em>float</em>) – The power resolution (dp) for matrix generation.</p></li>
<li><p><strong>dq</strong> (<em>float</em>) – The reactive power resolution (dq) for matrix generation.</p></li>
<li><p><strong>init_pcc_pq</strong> (<em>tuple</em>) – Initial values for power (P) and reactive power (Q) of the PCC.</p></li>
<li><p><strong>small_fsp_prof</strong> (<em>numpy.ndarray/list</em>) – The sampled p,q setpoints for the small DG.</p></li>
<li><p><strong>comp_fsp_v_sens</strong> (<em>float</em>) – The scenario voltage sensitivity.</p></li>
<li><p><strong>comp_fsp_l_sens</strong> (<em>float</em>) – The scenario loading sensitivity.</p></li>
<li><p><strong>min_max_v</strong> (<em>list</em><em>[</em><em>float</em><em>, </em><em>float</em><em>]</em>) – The scenario network voltage constraints.</p></li>
<li><p><strong>max_l</strong> (<em>float</em>) – The scenario network loading constraints.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>The flexibility area (FA), the uncertainty including flexibility area, the reachable area,
the binary flexibility area, the p index of initial operating point, the q index of initial operating
point, a string on the simulation duration, extra info depending on scenario.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>pandas.Dataframe, pandas.Dataframe, pandas.Dataframe, pandas.Dataframe, float, float, str,
pandas.Dataframe</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py">
<span class="sig-prename descclassname"><span class="pre">conv_simulations.</span></span><span class="sig-name descname"><span class="pre">update_conv_pqs</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">net</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fsp_idx</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fsp_type</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">profile</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>Update the FSPs to perform power flows.
This function updates the FSPs to perform power flows.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>net</strong> (<em>pandapower.network</em>) – The distribution network.</p></li>
<li><p><strong>fsp_idx</strong> (<em>int</em>) – The index value of the FSP in the network.</p></li>
<li><p><strong>fsp_type</strong> (<em>str</em>) – The type of the FSP in the network.</p></li>
<li><p><strong>profile</strong> (<em>list</em><em>[</em><em>float</em><em>, </em><em>float</em><em>]</em>) – The p,q new setpoints for the FSP.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>Updated network.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>pandapower.network</p>
</dd>
</dl>
</dd></dl>

</section>
<section id="monte-carlo">
<h3>Monte Carlo<a class="headerlink" href="#monte-carlo" title="Link to this heading"></a></h3>
<p>This Python Script includes all functions applying Monte-Carlo based simulations.</p>
<dl class="py function">
<dt class="sig sig-object py">
<span class="sig-prename descclassname"><span class="pre">monte_carlo.</span></span><span class="sig-name descname"><span class="pre">all_pf_simulations</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">settings</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">net</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">pq_profiles</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>main function running all power flow simulations based on which FSP types will be used.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>settings</strong> (<em>object</em>) – Information of the json file.</p></li>
<li><p><strong>net</strong> (<em>pandapower.network</em>) – Network on which the simulations will be performed.</p></li>
<li><p><strong>pq_profiles</strong> (<em>list</em>) – P and Q values for each FSP for each iteration in the Monte Carlo simulation.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>feasible P, feasible Q, infeasible P, infeasible Q, duration of simulations [s],
FSP PQ values for the feasible y, FSP PQ values for the infeasible y.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>list, list, list, list, float, list, list</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py">
<span class="sig-prename descclassname"><span class="pre">monte_carlo.</span></span><span class="sig-name descname"><span class="pre">get_fsp_ids</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">fsp</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dataframe</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>Get ID of fsp number.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>fsp</strong> (<em>list</em>) – fsp numbers.</p></li>
<li><p><strong>dataframe</strong> (<em>pandas.dataframe</em>) – fsp information.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>ids of fsps.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>list</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py">
<span class="sig-prename descclassname"><span class="pre">monte_carlo.</span></span><span class="sig-name descname"><span class="pre">run_all_samples</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">settings</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">net</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">pq_profiles</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>Run all power flows for scenarios where only DG are used as FSP.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>settings</strong> (<em>object</em>) – information of the json file.</p></li>
<li><p><strong>net</strong> (<em>pandapower.network</em>) – Network on which the simulations will be performed.</p></li>
<li><p><strong>pq_profiles</strong> (<em>list</em>) – P and Q values for each FSP for each iteration in the Monte Carlo simulation.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>feasible P, feasible Q, infeasible P, infeasible Q, duration of simulations [s],
FSP PQ values for the feasible y, FSP PQ values for the infeasible y.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>list, list, list, list, float, list, list</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py">
<span class="sig-prename descclassname"><span class="pre">monte_carlo.</span></span><span class="sig-name descname"><span class="pre">run_all_samples_wl</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">settings</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">net</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">pq_profiles</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>Run all power flows for scenarios where loads are included in the FSP.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>settings</strong> (<em>object</em>) – information of the json file.</p></li>
<li><p><strong>net</strong> (<em>pandapower.network</em>) – network on which the simulations will be performed.</p></li>
<li><p><strong>pq_profiles</strong> (<em>list</em>) – P and Q values for each FSP for each iteration in the Monte Carlo simulation.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>feasible P, feasible Q, infeasible P, infeasible Q, duration of simulations [s],
FSP PQ values for the feasible y, FSP PQ values for the infeasible y.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>list, list, list, list, float, list, list</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py">
<span class="sig-prename descclassname"><span class="pre">monte_carlo.</span></span><span class="sig-name descname"><span class="pre">run_uc6</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">settings</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">net</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">pq_profiles</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>Run all power flows for scenarios where loads are included in the FSP.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>settings</strong> (<em>object</em>) – information of the json file.</p></li>
<li><p><strong>net</strong> (<em>pandapower.network</em>) – network on which the simulations will be performed.</p></li>
<li><p><strong>pq_profiles</strong> (<em>list</em>) – P and Q values for each FSP for each iteration in the Monte Carlo simulation.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>feasible P, feasible Q, infeasible P, infeasible Q, duration of simulations [s],
FSP PQ values for the feasible y, FSP PQ values for the infeasible y.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>list, list, list, list, float, list, list</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py">
<span class="sig-prename descclassname"><span class="pre">monte_carlo.</span></span><span class="sig-name descname"><span class="pre">run_uc6_volts</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">settings</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">net</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">v_profiles</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>Run all power flows for scenarios where loads are included in the FSP.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>settings</strong> (<em>object</em>) – information of the json file.</p></li>
<li><p><strong>net</strong> (<em>pandapower.network</em>) – network on which the simulations will be performed.</p></li>
<li><p><strong>pq_profiles</strong> (<em>list</em>) – P and Q values for each FSP for each iteration in the Monte Carlo simulation.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>feasible P, feasible Q, infeasible P, infeasible Q, duration of simulations [s],
FSP PQ values for the feasible y, FSP PQ values for the infeasible y.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>list, list, list, list, float, list, list</p>
</dd>
</dl>
</dd></dl>

</section>
<section id="data-sampler">
<h3>Data Sampler<a class="headerlink" href="#data-sampler" title="Link to this heading"></a></h3>
<p>This Python Script includes all functions sampling FSP shifts.</p>
<dl class="py function">
<dt class="sig sig-object py">
<span class="sig-prename descclassname"><span class="pre">data_sampler.</span></span><span class="sig-name descname"><span class="pre">append_margin_profiles</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">pq_profiles</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">max_s</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">p</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dp</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dq</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">no_samples</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>Add profiles for vertical shifts needed due to discretization.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>pq_profiles</strong> (<em>list</em>) – p,q values for the shifts.</p></li>
<li><p><strong>max_s</strong> (<em>float</em>) – maximum apparent power of component.</p></li>
<li><p><strong>p</strong> (<em>float</em>) – active power set-point.</p></li>
<li><p><strong>dp</strong> (<em>float</em>) – resolution in active power shifts.</p></li>
<li><p><strong>dq</strong> (<em>float</em>) – resolution in reactive power shifts.</p></li>
<li><p><strong>no_samples</strong> (<em>int</em>) – number of samples.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>new p,q profiles.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>list</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py">
<span class="sig-prename descclassname"><span class="pre">data_sampler.</span></span><span class="sig-name descname"><span class="pre">check_margins</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">max_s</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">p</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dp</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dq</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">no_samples</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>Check if new vertical shifts should be given due to the descritization.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>max_s</strong> (<em>float</em>) – maximum apparent power of component.</p></li>
<li><p><strong>p</strong> (<em>float</em>) – active power set-point.</p></li>
<li><p><strong>dp</strong> (<em>float</em>) – resolution in active power shifts.</p></li>
<li><p><strong>dq</strong> (<em>float</em>) – resolution in reactive power shifts.</p></li>
<li><p><strong>no_samples</strong> (<em>int</em>) – number of samples.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>how many additional vertical shift samples are needed.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>int</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py">
<span class="sig-prename descclassname"><span class="pre">data_sampler.</span></span><span class="sig-name descname"><span class="pre">combine_profiles</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">profiles</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">key_order_dg</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">key_order_load</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>Combine profiles from DGs and Loads.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>profiles</strong> (<em>list</em>) – profiles generated for all (large) DGs.</p></li>
<li><p><strong>key_order_dg</strong> (<em>list</em>) – order of DG names in profile.</p></li>
<li><p><strong>key_order_load</strong> (<em>list</em>) – order of load names in profile.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>Combined profiles from all FSPs.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>list</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py">
<span class="sig-prename descclassname"><span class="pre">data_sampler.</span></span><span class="sig-name descname"><span class="pre">conv_profile_creation</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">dp</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dq</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">net</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">services</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'DG</span> <span class="pre">Only'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">flexible_loads</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">[]</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">flexible_dgs</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">[]</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">non_linear_dgs</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">[]</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>Create profiles for convolution simulations.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>dp</strong> (<em>float</em>) – Resolution in active power shifts that the algorithm will create and run.</p></li>
<li><p><strong>dq</strong> (<em>float</em>) – Resolution in reactive power shifts that the algorithm will create and run.</p></li>
<li><p><strong>net</strong> (<em>pandapower.network</em>) – PandaPower network in which the simulations are performed.</p></li>
<li><p><strong>services</strong> (<em>str</em>) – If FSPs are DG, Loads or both.</p></li>
<li><p><strong>flexible_loads</strong> (<em>list</em><em>[</em><em>int</em><em>]</em>) – Which Loads are considered FSPs.</p></li>
<li><p><strong>flexible_dgs</strong> (<em>list</em><em>[</em><em>int</em><em>]</em>) – Which DG are considered FSPs.</p></li>
<li><p><strong>non_linear_dgs</strong> (<em>list</em><em>[</em><em>int</em><em>]</em>) – Which FSP DGs are considered non-linear.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>The new active and reactive power for each FSP, for all power flow simulations, the active and reactive
power for each small FSP, the duration in seconds for the sample creations, the names of non-linear DGs.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>list, list, float, list</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py">
<span class="sig-prename descclassname"><span class="pre">data_sampler.</span></span><span class="sig-name descname"><span class="pre">conv_profile_creation_sq</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">dp</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dq</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">net</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">services</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'DG</span> <span class="pre">Only'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">flexible_loads</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">[]</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">flexible_dgs</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">[]</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">non_linear_dgs</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">[]</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>Create square shaped profiles for convolution simulations.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>dp</strong> (<em>float</em>) – Resolution in active power shifts that the algorithm will create and run.</p></li>
<li><p><strong>dq</strong> (<em>float</em>) – Resolution in reactive power shifts that the algorithm will create and run.</p></li>
<li><p><strong>net</strong> (<em>pandapower.network</em>) – PandaPower network in which the simulations are performed.</p></li>
<li><p><strong>services</strong> (<em>str</em>) – If FSPs are DG, Loads or both.</p></li>
<li><p><strong>flexible_loads</strong> (<em>list</em><em>[</em><em>int</em><em>]</em>) – Which Loads are considered FSPs.</p></li>
<li><p><strong>flexible_dgs</strong> (<em>list</em><em>[</em><em>int</em><em>]</em>) – Which DG are considered FSPs.</p></li>
<li><p><strong>non_linear_dgs</strong> (<em>list</em><em>[</em><em>int</em><em>]</em>) – Which FSP DGs are considered non-linear.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>The new active and reactive power for each FSP, for all power flow simulations, the active and reactive
power for each small FSP, the duration in seconds for the sample creations, the names of non-linear DGs.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>list, list, float, list</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py">
<span class="sig-prename descclassname"><span class="pre">data_sampler.</span></span><span class="sig-name descname"><span class="pre">create_all_fsp_samples</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">dp</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dq</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fsps</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">non_linear_dg_names</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>Create all FSP samples for the Convolution based simulations.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>dp</strong> (<em>float</em>) – Resolution in active power shifts that the algorithm will create and run.</p></li>
<li><p><strong>dq</strong> (<em>float</em>) – Resolution in reactive power shifts that the algorithm will create and run.</p></li>
<li><p><strong>fsps</strong> (<em>pandas.dataframe</em>) – dataframe of relevant data for the fsps.</p></li>
<li><p><strong>non_linear_dg_names</strong> (<em>list</em><em>[</em><em>str</em><em>]</em>) – names of not linear DGs.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>profiles for FSP, profiles for small FSP, duration for sample generation.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>list, list, float</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py">
<span class="sig-prename descclassname"><span class="pre">data_sampler.</span></span><span class="sig-name descname"><span class="pre">create_all_fsp_samples_sq</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">dp</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dq</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fsps</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">non_linear_dg_names</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>Create all FSP samples for the Convolution based simulations.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>dp</strong> (<em>float</em>) – Resolution in active power shifts that the algorithm will create and run.</p></li>
<li><p><strong>dq</strong> (<em>float</em>) – Resolution in reactive power shifts that the algorithm will create and run.</p></li>
<li><p><strong>fsps</strong> (<em>pandas.dataframe</em>) – dataframe of relevant data for the fsps.</p></li>
<li><p><strong>non_linear_dg_names</strong> (<em>list</em><em>[</em><em>str</em><em>]</em>) – names of not linear DGs.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>profiles for FSP, profiles for small FSP, duration for sample generation.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>list, list, float</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py">
<span class="sig-prename descclassname"><span class="pre">data_sampler.</span></span><span class="sig-name descname"><span class="pre">create_load_samples</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">no_samples</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">net</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">distribution</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">flex_loads</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">rng</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>Creation of {no_samples} of new [P, Q] for each load FSP. These new [P,Q] are
a flexibility activation [ΔP, ΔQ] applied on the initial output [P_0, Q_0] of each load FSP.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>no_samples</strong> (<em>int</em>) – Amount of shifts that the function will create.</p></li>
<li><p><strong>net</strong> (<em>pandapower.network</em>) – PandaPower network in which the simulations are performed.</p></li>
<li><p><strong>distribution</strong> (<em>str</em>) – Type of distribution by which the new [P,Q] samples are obtained.</p></li>
<li><p><strong>flex_loads</strong> (<em>list</em><em>[</em><em>int</em><em>]</em>) – Which Loads are considered FSPs.</p></li>
<li><p><strong>rng</strong> (<em>np.random</em>) – Function by which the random numbers are generated.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>The new active and reactive power for each load FSP, for the {no_samples}, the duration in seconds for the
sample creations [float].</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>list, float</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py">
<span class="sig-prename descclassname"><span class="pre">data_sampler.</span></span><span class="sig-name descname"><span class="pre">create_samples</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">no_samples</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">net_sgen</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">distribution</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">keep_mp</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">rng</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">non_lin_fsps</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">[]</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>Creation of {no_samples} of new [P, Q] for each DG FSP. These new [P,Q] are
a flexibility activation [ΔP, ΔQ] applied on the initial output [P_0, Q_0] of each DG FSP.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>no_samples</strong> (<em>int</em>) – Amount of shifts that the function will create, [int].</p></li>
<li><p><strong>net_sgen</strong> (<em>pandas.dataframe</em><em> (</em><em>pandapower</em><em>)</em>) – PandaPower network sgen.</p></li>
<li><p><strong>distribution</strong> (<em>str</em>) – Type of distribution by which the new [P,Q] samples are obtained.</p></li>
<li><p><strong>keep_mp</strong> (<em>bool</em>) – Boolean whether the DG FSP shifts only concern the output power factor
(keeping maximum output power), or can also reduce the DG FSP power output/consumption.</p></li>
<li><p><strong>rng</strong> (<em>np.random</em>) – Function by which the random numbers are generated.</p></li>
<li><p><strong>non_lin_fsps</strong> (<em>list</em><em>[</em><em>int</em><em>]</em>) – FSPs that only offer 2 setpoint options (full or no curtailment).</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>The new active and reactive power for each DG FSP, for the {no_samples}, the duration in seconds for the
sample creations [float].</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>list, float</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py">
<span class="sig-prename descclassname"><span class="pre">data_sampler.</span></span><span class="sig-name descname"><span class="pre">get_fsps</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">comps</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">comp_no_list</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>Get important information for FSPs.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>comps</strong> (<em>pandas.dataframe</em><em> (</em><em>pandapower</em><em>)</em>) – network components.</p></li>
<li><p><strong>comp_no_list</strong> (<em>list</em><em>[</em><em>int</em><em>]</em>) – list of FSPs numbers in the network.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>relevant FSP information.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>pandas.dataframe</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py">
<span class="sig-prename descclassname"><span class="pre">data_sampler.</span></span><span class="sig-name descname"><span class="pre">get_fsps_with_idx</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">comps</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">comp_no_list</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>Get important information for FSPs.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>comps</strong> (<em>pandas.dataframe</em><em> (</em><em>pandapower</em><em>)</em>) – network components.</p></li>
<li><p><strong>comp_no_list</strong> (<em>list</em><em>[</em><em>int</em><em>]</em>) – list of FSPs numbers in the network.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>relevant FSP information, names of ordered FSPs.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>pandas.dataframe, list</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py">
<span class="sig-prename descclassname"><span class="pre">data_sampler.</span></span><span class="sig-name descname"><span class="pre">get_non_linear_comp</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">comps</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">non_linear_no</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>Get names of not linear FSPs.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>comps</strong> (<em>pandas.dataframe</em><em> (</em><em>pandapower</em><em>)</em>) – network components.</p></li>
<li><p><strong>non_linear_no</strong> (<em>list</em><em>[</em><em>int</em><em>]</em>) – number of not linear FSPs.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>names of not linear FSPs.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>list</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py">
<span class="sig-prename descclassname"><span class="pre">data_sampler.</span></span><span class="sig-name descname"><span class="pre">get_oltcs</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">comps</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">comp_no_list</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>Get important information for FSPs.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>comps</strong> (<em>pandas.dataframe</em><em> (</em><em>pandapower</em><em>)</em>) – network components.</p></li>
<li><p><strong>comp_no_list</strong> (<em>list</em><em>[</em><em>int</em><em>]</em>) – list of FSPs numbers in the network.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>relevant FSP information.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>pandas.dataframe</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py">
<span class="sig-prename descclassname"><span class="pre">data_sampler.</span></span><span class="sig-name descname"><span class="pre">profile_creation</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">no_samples</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">net</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">distribution</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">keep_mp</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">services</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'DG</span> <span class="pre">Only'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">flexible_loads</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">[]</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">flexible_dg</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">[]</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">non_lin_dgs</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">[]</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>Creation of {no_samples} of new [P, Q] for each FSP. These new [P,Q] are
a flexibility activation [ΔP, ΔQ] applied on the initial output [P_0, Q_0] of each FSP.
Based on the services (i.e. DG, Load, or Both), the more specific functions for sample creation are called.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>no_samples</strong> (<em>int</em>) – Amount of shifts that the algorithm will create and run.</p></li>
<li><p><strong>net</strong> (<em>pandapower.network</em>) – PandaPower network in which the simulations are performed.</p></li>
<li><p><strong>distribution</strong> (<em>str</em>) – Type of distribution by which the new [P,Q] samples are obtained.</p></li>
<li><p><strong>keep_mp</strong> (<em>bool</em>) – Boolean whether the DG FSP shifts only concern the output power factor (keeping maximum output
power), or can also reduce the DG FSP power output/consumption.</p></li>
<li><p><strong>services</strong> (<em>str</em>) – If FSPs are DG, Loads or both.</p></li>
<li><p><strong>flexible_loads</strong> (<em>list</em><em>[</em><em>int</em><em>]</em>) – Which Loads are considered FSPs.</p></li>
<li><p><strong>flexible_dg</strong> (<em>list</em><em>[</em><em>int</em><em>]</em>) – Which DG are considered FSPs.</p></li>
<li><p><strong>non_lin_dgs</strong> (<em>list</em><em>[</em><em>int</em><em>]</em>) – Which FSP DGs are considered non-linear.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>The new active and reactive power for each FSP, for all power flow simulations, the duration in seconds
for the sample creations.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>list, float</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py">
<span class="sig-prename descclassname"><span class="pre">data_sampler.</span></span><span class="sig-name descname"><span class="pre">profile_creation_bf</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">dp</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dq</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">net</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">services</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'DG</span> <span class="pre">Only'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">flexible_loads</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">[]</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">flexible_dgs</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">[]</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">non_linear_dgs</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">[]</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>Creation of {no_samples} of new [P, Q] for each FSP for the Brute Force case. These new [P,Q] are
a flexibility activation [ΔP, ΔQ] applied on the initial output [P_0, Q_0] of each FSP.
Based on the services (i.e. DG, Load, or Both), the more specific functions for sample creation are called.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>dp</strong> (<em>float</em>) – Resolution in active power shifts that the algorithm will create and run.</p></li>
<li><p><strong>dq</strong> (<em>float</em>) – Resolution in reactive power shifts that the algorithm will create and run.</p></li>
<li><p><strong>net</strong> (<em>pandapower.network</em>) – PandaPower network in which the simulations are performed.</p></li>
<li><p><strong>services</strong> (<em>str</em>) – If FSPs are DG, Loads or both.</p></li>
<li><p><strong>flexible_loads</strong> (<em>list</em><em>[</em><em>int</em><em>]</em>) – Which Loads are considered FSPs.</p></li>
<li><p><strong>flexible_dgs</strong> (<em>list</em><em>[</em><em>int</em><em>]</em>) – Which DG are considered FSPs.</p></li>
<li><p><strong>non_linear_dgs</strong> (<em>list</em><em>[</em><em>int</em><em>]</em>) – Which FSP DGs are considered non-linear.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>The new active and reactive power for each FSP, for all power flow simulations, the active and reactive
power for each small FSP, the duration in seconds for the sample creations, the names of non-linear DGs,
the number of samples.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>list, list, float, list, int</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py">
<span class="sig-prename descclassname"><span class="pre">data_sampler.</span></span><span class="sig-name descname"><span class="pre">sample_from_rng</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">distribution</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">no_samples_dg</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dof</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">rng</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>Based on the type of distribution, this function generates {no_samples_dg} for the flexibility activations which
do not yet concern for the limits of each FSP and will later be applied on each FSP.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>distribution</strong> (<em>str</em>) – Type of distribution used for the data generation.</p></li>
<li><p><strong>no_samples_dg</strong> (<em>int</em>) – Number of samples to be generated.</p></li>
<li><p><strong>dof</strong> (<em>int</em><em> (</em><em>1</em><em> or </em><em>2</em><em>)</em>) – Generated based on the ‘keep_mp’ variable. If dof=1, the random number generated for the
active power P also defines the shift for the reactive power Q to keep S constant.</p></li>
<li><p><strong>rng</strong> (<em>numpy.random</em>) – RNG function to be used to generate the data, is defined outside of the function to return the
same results at each simulation (through a seed) but to avoid returning the same numbers if it is called
multiple times in one simulation.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>array of generated random values to be used for the FSP activations.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>np.array</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py">
<span class="sig-prename descclassname"><span class="pre">data_sampler.</span></span><span class="sig-name descname"><span class="pre">sample_fsp_thorough_points</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">fsp</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dp</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dq</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>Sample FSP shifts for all spectrum in dp, dq resolution.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>fsp</strong> (<em>pandas.dataframe</em>) – dataframe of relevant data for the fsps.</p></li>
<li><p><strong>dp</strong> (<em>float</em>) – Resolution in active power shifts that the algorithm will create and run.</p></li>
<li><p><strong>dq</strong> (<em>float</em>) – Resolution in reactive power shifts that the algorithm will create and run.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>p,q values as setpoints for the FSP shifts.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>list</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py">
<span class="sig-prename descclassname"><span class="pre">data_sampler.</span></span><span class="sig-name descname"><span class="pre">sample_fsp_thorough_points_sq</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">fsp</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dp</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dq</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>Sample FSP shifts for all spectrum in dp, dq resolution.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>fsp</strong> (<em>pandas.dataframe</em>) – dataframe of relevant data for the fsps.</p></li>
<li><p><strong>dp</strong> (<em>float</em>) – Resolution in active power shifts that the algorithm will create and run.</p></li>
<li><p><strong>dq</strong> (<em>float</em>) – Resolution in reactive power shifts that the algorithm will create and run.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>p,q values as setpoints for the FSP shifts.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>list</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py">
<span class="sig-prename descclassname"><span class="pre">data_sampler.</span></span><span class="sig-name descname"><span class="pre">sample_new_load_point</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">loads</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">random_p</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">no_samples</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">flex_loads</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">[]</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>This function is called to apply the generated random shifts on Load FSPs.
Based on the random values generated for active and reactive power shifts, it checks that:
(1) The active power shift percentages are between [0%, 100%], to avoid negative or increased consumption values
(2) The reactive power shifts will not cause abs(S new) &gt; abs(S initial).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>loads</strong> (<em>pandas.dataframe</em>) – Load FSP.</p></li>
<li><p><strong>random_p</strong> (<em>numpy array</em>) – Loop values for the P Q shifts.</p></li>
<li><p><strong>no_samples</strong> (<em>int</em>) – Number of samples for the applied shifts.</p></li>
<li><p><strong>flex_loads</strong> (<em>list</em>) – Which loads of flexible out of all the network loads. If empty, it is assumed that all loads are
flexible (since this function is called when at least 1 load is flexible.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>no_samples of new P and Q values for the Load FSPs.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>list</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py">
<span class="sig-prename descclassname"><span class="pre">data_sampler.</span></span><span class="sig-name descname"><span class="pre">sample_new_non_mp_point</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">sgen</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">random_p</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">no_samples</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">non_lin_fsps</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">[]</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>This function is called when keep_mp is false for DG FSPs.
Based on the random values generated for active and reactive power shifts, it checks that:
(1) The active power shift percentages are between [0%, 100%], to avoid negative or increased generation values.
(2) The reactive power shifts will not cause abs(S new) &gt; abs(S initial).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>sgen</strong> (<em>pandas.dataframe</em>) – DG FSP.</p></li>
<li><p><strong>random_p</strong> (<em>numpy array</em>) – Loop values for the P shift.</p></li>
<li><p><strong>no_samples</strong> (<em>int</em>) – Number of samples for the applied shifts.</p></li>
<li><p><strong>non_lin_fsps</strong> (<em>list</em>) – Number of not linear FSPs.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>no_samples of new P and Q values for the DG FSPs.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>list</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py">
<span class="sig-prename descclassname"><span class="pre">data_sampler.</span></span><span class="sig-name descname"><span class="pre">sample_new_point</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">sgen</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">random_p</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">no_samples</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">non_lin_fsps</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">[]</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>This function is called when the keep_mp is true for DG FSPs.
Based on the random values generated for active power shifts,
it applies the shifts on P, and applies shifts is Q which will keep the S of the DG FSP same as the initial.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>sgen</strong> (<em>pandas.dataframe</em>) – DG FSP.</p></li>
<li><p><strong>random_p</strong> (<em>numpy array</em>) – Loop values for the P shift.</p></li>
<li><p><strong>no_samples</strong> (<em>int</em>) – Number of samples for the applied shifts.</p></li>
<li><p><strong>non_lin_fsps</strong> (<em>list</em>) – Number of not linear FSPs.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>{no_samples} of new P and Q values for the DG FSPs.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>list</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py">
<span class="sig-prename descclassname"><span class="pre">data_sampler.</span></span><span class="sig-name descname"><span class="pre">sample_non_lin_fsp</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">fsp</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dp</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dq</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>Get the shifts for the non linear FSPs (this can be modified to also offer different scenarios for non-linear FSPs).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>fsp</strong> (<em>pandas.dataframe</em>) – relevant information for not linear FSPs.</p></li>
<li><p><strong>dp</strong> (<em>float</em>) – resolution in active power shifts.</p></li>
<li><p><strong>dq</strong> (<em>float</em>) – resolution in reactive power shifts.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>list of new setpoints (profiles) for not linear FSPs.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>list</p>
</dd>
</dl>
</dd></dl>

</section>
<section id="json-reader">
<h3>Json Reader<a class="headerlink" href="#json-reader" title="Link to this heading"></a></h3>
<p>This Python Script reads the scenario information.</p>
<dl class="py class">
<dt class="sig sig-object py">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">json_reader.</span></span><span class="sig-name descname"><span class="pre">SettingReader</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">scenario_name</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'unaltered_network'</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>Class parsing through the json scenario input files, checking their validity and saving their information.</p>
<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">tester</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span></dt>
<dd><p>Test that the imported information from the file is as expected and should not cause issues later.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p></p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p></p>
</dd>
</dl>
</dd></dl>

</dd></dl>

</section>
<section id="plotting">
<h3>Plotting<a class="headerlink" href="#plotting" title="Link to this heading"></a></h3>
<p>This Python Script includes all functions plotting the csv results.</p>
<dl class="py function">
<dt class="sig sig-object py">
<span class="sig-prename descclassname"><span class="pre">plotting.</span></span><span class="sig-name descname"><span class="pre">box_plt1</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">plt1_dict</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">acc_type</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>Plot accuracy information.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>plt1_dict</strong> (<em>dict</em>) – dictionary with accuracy info.</p></li>
<li><p><strong>acc_type</strong> (<em>str</em>) – type of accuracy.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p></p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p></p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py">
<span class="sig-prename descclassname"><span class="pre">plotting.</span></span><span class="sig-name descname"><span class="pre">box_plt3</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">plt1_dict</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">est_dict</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>Generate speed plots.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>plt1_dict</strong> (<em>dict</em>) – dictionary with speed information.</p></li>
<li><p><strong>est_dict</strong> (<em>dict</em>) – estimation dictionary.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p></p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p></p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py">
<span class="sig-prename descclassname"><span class="pre">plotting.</span></span><span class="sig-name descname"><span class="pre">get_estimated_times</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span></dt>
<dd><p>Get dictionaries from results of UC2.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>net_name</strong> (<em>str</em>) – network name.</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>dictionaries with info, names of accuracy columns, names of time columns.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>dict, list, list</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py">
<span class="sig-prename descclassname"><span class="pre">plotting.</span></span><span class="sig-name descname"><span class="pre">get_means12</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">plt_dict</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>Get mean values from results.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>plt_dict</strong> (<em>dict</em>) – dictionary with results.</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>dictionary with mean values.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>dict</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py">
<span class="sig-prename descclassname"><span class="pre">plotting.</span></span><span class="sig-name descname"><span class="pre">get_rel_dicts</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">net_name</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>Get dictionaries from results of UC2.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>net_name</strong> (<em>str</em>) – network name.</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>dictionaries with info, names of accuracy columns, names of time columns.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>dict, list, list</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py">
<span class="sig-prename descclassname"><span class="pre">plotting.</span></span><span class="sig-name descname"><span class="pre">get_uncertainty</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">df</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">name</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">''</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">plot_type</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'jpg'</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>Plot results including uncertainty.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>df</strong> (<em>pandas.dataframe</em>) – dataframe with results.</p></li>
<li><p><strong>name</strong> (<em>str</em>) – name for saving.</p></li>
<li><p><strong>plot_type</strong> (<em>str</em>) – type of figure to be saved.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p></p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p></p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py">
<span class="sig-prename descclassname"><span class="pre">plotting.</span></span><span class="sig-name descname"><span class="pre">get_uncertainty_interpret</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">uncert_df</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">safe_df</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ones_df</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">name</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">''</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">plot_type</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'pdf'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">extra</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">[]</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>Plot results including uncertainty.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>uncert_df</strong> (<em>pandas.dataframe</em>) – uncertainty dataframe.</p></li>
<li><p><strong>safe_df</strong> (<em>pandas.dataframe</em>) – certain dataframe.</p></li>
<li><p><strong>ones_df</strong> (<em>pandas.dataframe</em>) – reachable dataframe.</p></li>
<li><p><strong>name</strong> (<em>str</em>) – name to save results.</p></li>
<li><p><strong>plot_type</strong> (<em>str</em>) – type of plot to save in.</p></li>
<li><p><strong>extra</strong> (<em>list</em>) – initial P,Q values pixel location.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p></p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p></p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py">
<span class="sig-prename descclassname"><span class="pre">plotting.</span></span><span class="sig-name descname"><span class="pre">plot_feasible_and_infeasible</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x_flexible</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y_flexible</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">x_non_flexible</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y_non_flexible</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">operating_point</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">scenario_name</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">text</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">loc</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">''</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>Plot Monte Carlo simulation results including infeasible samples.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>x_flexible</strong> (<em>list</em>) – feasible P.</p></li>
<li><p><strong>y_flexible</strong> (<em>list</em>) – feasible Y.</p></li>
<li><p><strong>x_non_flexible</strong> (<em>list</em>) – infeasible P.</p></li>
<li><p><strong>y_non_flexible</strong> (<em>list</em>) – infeasible Q.</p></li>
<li><p><strong>operating_point</strong> (<em>list</em><em>[</em><em>float</em><em>, </em><em>float</em><em>]</em>) – initial PCC p,q.</p></li>
<li><p><strong>scenario_name</strong> (<em>str</em>) – name of used scenario.</p></li>
<li><p><strong>text</strong> (<em>str</em>) – information accompanying plot.</p></li>
<li><p><strong>loc</strong> (<em>str</em>) – location on disc.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p></p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p></p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py">
<span class="sig-prename descclassname"><span class="pre">plotting.</span></span><span class="sig-name descname"><span class="pre">plot_mc</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x_flexible</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y_flexible</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">x_non_flexible</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y_non_flexible</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">operating_point</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">no_samples</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">scenario_name</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dur_samples</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dur_pf</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">loc</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">''</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>Plot Monte Carlo simulation results.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>x_flexible</strong> (<em>list</em>) – feasible P.</p></li>
<li><p><strong>y_flexible</strong> (<em>list</em>) – feasible Y.</p></li>
<li><p><strong>x_non_flexible</strong> (<em>list</em>) – infeasible P.</p></li>
<li><p><strong>y_non_flexible</strong> (<em>list</em>) – infeasible Q.</p></li>
<li><p><strong>operating_point</strong> (<em>list</em><em>[</em><em>float</em><em>, </em><em>float</em><em>]</em>) – initial PCC p,q.</p></li>
<li><p><strong>no_samples</strong> (<em>int</em>) – number of samples run.</p></li>
<li><p><strong>scenario_name</strong> (<em>str</em>) – name of used scenario.</p></li>
<li><p><strong>dur_samples</strong> (<em>float</em>) – duration for sample creations [s].</p></li>
<li><p><strong>dur_pf</strong> (<em>float</em>) – duration for power flows [s].</p></li>
<li><p><strong>loc</strong> (<em>str</em>) – location on disc.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p></p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p></p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py">
<span class="sig-prename descclassname"><span class="pre">plotting.</span></span><span class="sig-name descname"><span class="pre">plot_multi_convolution</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">filename</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">inf</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">q_loc</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">p_loc</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">text</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">loc</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">''</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>Plot convolution algorithm result.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>filename</strong> (<em>str</em>) – name of file with results.</p></li>
<li><p><strong>inf</strong> (<em>pandas.dataframe</em>) – dataframe with infeasible samples.</p></li>
<li><p><strong>q_loc</strong> (<em>int</em>) – height pixel of initial Q of PCC.</p></li>
<li><p><strong>p_loc</strong> (<em>int</em>) – width pixel of initial P of PCC.</p></li>
<li><p><strong>text</strong> (<em>str</em>) – information accompanying plot.</p></li>
<li><p><strong>loc</strong> (<em>str</em>) – location on disc.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p></p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p></p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py">
<span class="sig-prename descclassname"><span class="pre">plotting.</span></span><span class="sig-name descname"><span class="pre">plot_only_feasible</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x_flexible</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y_flexible</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">operating_point</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">scenario_name</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">loc</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">''</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>Plot Monte Carlo simulation results only for feasible samples.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>x_flexible</strong> (<em>list</em>) – feasible P.</p></li>
<li><p><strong>y_flexible</strong> (<em>list</em>) – feasible Y.</p></li>
<li><p><strong>operating_point</strong> (<em>list</em><em>[</em><em>float</em><em>, </em><em>float</em><em>]</em>) – initial PCC p,q.</p></li>
<li><p><strong>scenario_name</strong> (<em>str</em>) – name of used scenario.</p></li>
<li><p><strong>loc</strong> (<em>str</em>) – location on disc.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p></p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p></p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py">
<span class="sig-prename descclassname"><span class="pre">plotting.</span></span><span class="sig-name descname"><span class="pre">plot_opf_res</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">filename</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">init_pq</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">text</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>Plot the OPF results.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>filename</strong> (<em>str</em>) – name of the OPF results to get for the plot.</p></li>
<li><p><strong>init_pq</strong> (<em>list</em><em>[</em><em>floats</em><em>]</em>) – initial active and reactive power of the PCC.</p></li>
<li><p><strong>text</strong> (<em>str</em>) – information accompanying plot.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p></p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p></p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py">
<span class="sig-prename descclassname"><span class="pre">plotting.</span></span><span class="sig-name descname"><span class="pre">plot_uc3</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">net1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">net2</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>Plot use case 3 figures.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>net1</strong> (<em>str</em>) – network 1.</p></li>
<li><p><strong>net2</strong> (<em>str</em>) – network 2.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p></p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p></p>
</dd>
</dl>
</dd></dl>

</section>
<section id="scenario-setup">
<h3>Scenario Setup<a class="headerlink" href="#scenario-setup" title="Link to this heading"></a></h3>
<p>This Python Script includes all functions setting up the network and scenario parameters.</p>
<dl class="py function">
<dt class="sig sig-object py">
<span class="sig-prename descclassname"><span class="pre">scenario_setup.</span></span><span class="sig-name descname"><span class="pre">apply_cs</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">net</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">settings</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>Apply CS scenario shifts on the network</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>net</strong> (<em>pandapower.network</em>) – Network model for scenario</p></li>
<li><p><strong>settings</strong> (<em>object</em>) – json file input data</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>network updated for the USS# case, network new PCC P,Q (y)</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>pandapower.network, list[float, float]</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py">
<span class="sig-prename descclassname"><span class="pre">scenario_setup.</span></span><span class="sig-name descname"><span class="pre">apply_tss</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">net</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">settings</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>Apply TSS scenario shifts on the network</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>net</strong> (<em>pandapower.network</em>) – Network model for scenario</p></li>
<li><p><strong>settings</strong> (<em>object</em>) – json file input data</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>network updated for the USS# case, network new PCC P,Q (y)</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>pandapower.network, list[float, float]</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py">
<span class="sig-prename descclassname"><span class="pre">scenario_setup.</span></span><span class="sig-name descname"><span class="pre">apply_uss</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">net</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">settings</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>Apply USS scenario shifts on the network</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>net</strong> (<em>pandapower.network</em>) – Network model for scenario</p></li>
<li><p><strong>settings</strong> (<em>object</em>) – json file input data</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>network updated for the USS# case, network new PCC P,Q (y)</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>pandapower.network, list[float, float]</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py">
<span class="sig-prename descclassname"><span class="pre">scenario_setup.</span></span><span class="sig-name descname"><span class="pre">get_fsp</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">settings</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>Get indices of FSPs if any of them are specified as -1.
This value , -1, is used to say ‘I do not know the indices but all components of type x are assumed FSPs</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>settings</strong> (<em>object</em>) – json file input data</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>updated settings object</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>object</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py">
<span class="sig-prename descclassname"><span class="pre">scenario_setup.</span></span><span class="sig-name descname"><span class="pre">get_network</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">settings</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>Gen the network specified in settings. Currently, only “CIGRE MV” with der “pv_wind” is implemented</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>settings</strong> (<em>object</em>) – json file input data</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>network model</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>pandapower.network</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py">
<span class="sig-prename descclassname"><span class="pre">scenario_setup.</span></span><span class="sig-name descname"><span class="pre">get_observable_lines_buses</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">settings</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>Get indices of observable lines and buses if any of them are specified as -1.
This value , -1, is used to say ‘I do not know the indices but all components of type x are assumed observable</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>settings</strong> (<em>object</em>) – json file input data</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>updated settings object</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>object</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py">
<span class="sig-prename descclassname"><span class="pre">scenario_setup.</span></span><span class="sig-name descname"><span class="pre">get_operating_point</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">settings</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>Get network PCC P,Q (y)</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>settings</strong> (<em>object</em>) – json file input data</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>Network PCC P,Q (y)</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>list[float, float]</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py">
<span class="sig-prename descclassname"><span class="pre">scenario_setup.</span></span><span class="sig-name descname"><span class="pre">get_unobservable_lines_buses_indices</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">settings</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>Gen indices of network unobservable lines (all lines not specified as observable)</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>settings</strong> (<em>object</em>) – json file input data</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>updated settings object</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>object</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py">
<span class="sig-prename descclassname"><span class="pre">scenario_setup.</span></span><span class="sig-name descname"><span class="pre">rand_resample</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">net</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">no_change_loads</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">no_change_dgs</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">rng</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">std_cap_l</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">std_pf_l</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">std_cap_dg</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">std_pf_dg</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>Randomly sample Operating Condition shift for adaptability case study</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>net</strong> (<em>pandapower.network</em>) – Network model for scenario</p></li>
<li><p><strong>no_change_loads</strong> (<em>list</em>) – loads not to change (FSPs)</p></li>
<li><p><strong>no_change_dgs</strong> (<em>list</em>) – DGS not to change (FSPs)</p></li>
<li><p><strong>rng</strong> (<em>numpy.random</em>) – object to sample random values from</p></li>
<li><p><strong>std_cap_l</strong> (<em>float</em>) – standard deviation for load capacities</p></li>
<li><p><strong>std_pf_l</strong> (<em>float</em>) – standard deviation for load power factor</p></li>
<li><p><strong>std_cap_dg</strong> (<em>float</em>) – standard deviation for DG capacities</p></li>
<li><p><strong>std_pf_dg</strong> (<em>float</em>) – standard deviation for DG power factor</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>network and used random function</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>pandapower.network, numpy.random</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py">
<span class="sig-prename descclassname"><span class="pre">scenario_setup.</span></span><span class="sig-name descname"><span class="pre">update_settings</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">settings</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>Update settings by changing observable and unobservable bus and line information based on the loaded network</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>settings</strong> (<em>object</em>) – json file input data</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>updated settings object</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>object</p>
</dd>
</dl>
</dd></dl>

</section>
<section id="accuracy-estimation">
<h3>Accuracy Estimation<a class="headerlink" href="#accuracy-estimation" title="Link to this heading"></a></h3>
<p>This Python Script includes all functions used to estimate the accuracy.</p>
<dl class="py function">
<dt class="sig sig-object py">
<span class="sig-prename descclassname"><span class="pre">accuracy_estimation.</span></span><span class="sig-name descname"><span class="pre">accuracy_brute_force</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">ground_truth_file</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">conv_results_file</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">decimals</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">operating_point</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>Calculate and print mean squared error (MSE) for feasible and total points.
This function calculates the mean squared error (MSE) for feasible and total points between ground truth data and
results. It takes ground truth data, convex results, a number of decimals, and an operating point. It also
generates a heatmap plot and saves it as an SVG file.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>ground_truth_file</strong> (<em>str</em>) – The filename of the ground truth data in CSV format.</p></li>
<li><p><strong>conv_results_file</strong> (<em>str</em>) – The filename of the convex results data in CSV format.</p></li>
<li><p><strong>decimals</strong> (<em>int</em>) – The number of decimals for rounding.</p></li>
<li><p><strong>operating_point</strong> (<em>list</em>) – The operating point as [P, Q] values.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p></p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p></p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py">
<span class="sig-prename descclassname"><span class="pre">accuracy_estimation.</span></span><span class="sig-name descname"><span class="pre">correct_feasible_and_infeasible</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">ground_truth_file</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">conv_results_file</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">inf</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dur_str</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>Evaluate the feasibility of points.
This function evaluates the feasibility of points based on ground truth data and results.
It takes ground truth data, convex results, infeasible points, and a duration string.
It calculates accuracy metrics and saves them in a log file.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>ground_truth_file</strong> (<em>str</em>) – The filename of the ground truth data in CSV format.</p></li>
<li><p><strong>conv_results_file</strong> (<em>str</em>) – The filename of the convex results data in CSV format.</p></li>
<li><p><strong>inf</strong> (<em>pandas.DataFrame</em>) – A DataFrame representing infeasible points.</p></li>
<li><p><strong>dur_str</strong> (<em>str</em>) – A duration string.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p></p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p></p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py">
<span class="sig-prename descclassname"><span class="pre">accuracy_estimation.</span></span><span class="sig-name descname"><span class="pre">extend_feasible_and_infeasible</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">ground_truth_file</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">conv_results_file</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">inf</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>Extend the feasible and infeasible regions for visualization.
This function extends the feasible and infeasible regions for visualization purposes.
It takes a ground truth file, convex results file, and a DataFrame ‘inf’ representing infeasible points.
It performs transformations on the data and generates a visualization.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>ground_truth_file</strong> (<em>str</em>) – The filename of the ground truth data in CSV format.</p></li>
<li><p><strong>conv_results_file</strong> (<em>str</em>) – The filename of the convex results data in CSV format.</p></li>
<li><p><strong>inf</strong> (<em>pandas.DataFrame</em>) – A DataFrame representing infeasible points.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p></p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p></p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py">
<span class="sig-prename descclassname"><span class="pre">accuracy_estimation.</span></span><span class="sig-name descname"><span class="pre">find_value_close2list</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">lst</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">voi</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>Find the index and closest value in a list to a specified value.
This function searches for the index and value in the input list <cite>lst</cite> that is closest to the specified value <cite>voi</cite>.
It iterates through the list and calculates the absolute difference between each element and <cite>voi</cite> to find the
closest match.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>lst</strong> (<em>list</em><em>[</em><em>float</em><em>]</em>) – The list to search for the closest value.</p></li>
<li><p><strong>voi</strong> (<em>float</em>) – The value to find the closest match for.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>The index of the closest value in the list and the closest value itself.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>int, float</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py">
<span class="sig-prename descclassname"><span class="pre">accuracy_estimation.</span></span><span class="sig-name descname"><span class="pre">get_heatmap_matrix</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x_flex</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y_flex</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">step_p</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">step_q</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">x_axis</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y_axis</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>Generate a heatmap matrix based on provided coordinates.
This function generates a heatmap matrix where specific coordinates in the matrix are incremented based on the
provided <cite>x_flex</cite> and <cite>y_flex</cite> coordinates. The matrix dimensions are determined by <cite>x_axis</cite> and <cite>y_axis</cite>, and the
spacing between points is defined by <cite>step_p</cite> and <cite>step_q</cite>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>x_flex</strong> (<em>list</em><em>[</em><em>float</em><em>]</em>) – List of x-coordinates to increment in the heatmap matrix.</p></li>
<li><p><strong>y_flex</strong> (<em>list</em><em>[</em><em>float</em><em>]</em>) – List of y-coordinates to increment in the heatmap matrix.</p></li>
<li><p><strong>step_p</strong> (<em>float</em>) – Spacing between x-axis points.</p></li>
<li><p><strong>step_q</strong> (<em>float</em>) – Spacing between y-axis points.</p></li>
<li><p><strong>x_axis</strong> (<em>list</em><em>[</em><em>float</em><em>]</em>) – List of x-axis values representing the matrix’s x-coordinates.</p></li>
<li><p><strong>y_axis</strong> (<em>list</em><em>[</em><em>float</em><em>]</em>) – List of y-axis values representing the matrix’s y-coordinates.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>A heatmap matrix with incremented coordinates and values normalized to the maximum value.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>numpy.ndarray</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py">
<span class="sig-prename descclassname"><span class="pre">accuracy_estimation.</span></span><span class="sig-name descname"><span class="pre">get_inf_matrix</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x_flex</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y_flex</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">step_p</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">step_q</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">x_axis</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y_axis</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>Generate the non-feasible space matrix based on provided data.
This function generates the non-feasible space matrix where specific coordinates in the matrix are marked as “1”
based on the provided <cite>x_flex</cite> and <cite>y_flex</cite> coordinates. The matrix dimensions are determined by <cite>x_axis</cite> and <cite>y_axis</cite>, and the
spacing between points is defined by <cite>step_p</cite> and <cite>step_q</cite>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>x_flex</strong> (<em>list</em><em>[</em><em>float</em><em>]</em>) – List of x-coordinates to mark as “1” in the infill matrix.</p></li>
<li><p><strong>y_flex</strong> (<em>list</em><em>[</em><em>float</em><em>]</em>) – List of y-coordinates to mark as “1” in the infill matrix.</p></li>
<li><p><strong>step_p</strong> (<em>float</em>) – Spacing between x-axis points.</p></li>
<li><p><strong>step_q</strong> (<em>float</em>) – Spacing between y-axis points.</p></li>
<li><p><strong>x_axis</strong> (<em>list</em><em>[</em><em>float</em><em>]</em><em>/numpy array</em>) – List of x-axis values representing the matrix’s x-coordinates.</p></li>
<li><p><strong>y_axis</strong> (<em>list</em><em>[</em><em>float</em><em>]</em><em>/numpy array</em>) – List of y-axis values representing the matrix’s y-coordinates.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>An infill matrix with marked coordinates as “1,” along with the x and y axis values and spacing.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>numpy.ndarray, list[float], list[float], float, float</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py">
<span class="sig-prename descclassname"><span class="pre">accuracy_estimation.</span></span><span class="sig-name descname"><span class="pre">get_info_matrix</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x_flex</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y_flex</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">x_nflex</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y_nflex</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">step_p</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">step_q</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">x_axis</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y_axis</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">maxv</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">minv</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">maxl</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cost</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">used_fsps</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">selected_pts</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">prof_flex</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>Get information for the case study “DFC Improving TSOs Flexibility Shift Selection”.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>x_flex</strong> (<em>list</em>) – flexible active power points at pcc.</p></li>
<li><p><strong>y_flex</strong> (<em>list</em>) – flexible reacitve power points at pcc.</p></li>
<li><p><strong>x_nflex</strong> (<em>list</em>) – not-flexible active power points at pcc.</p></li>
<li><p><strong>y_nflex</strong> (<em>list</em>) – not-flexible reactive power points at pcc.</p></li>
<li><p><strong>step_p</strong> (<em>float</em>) – active power resolution [mw].</p></li>
<li><p><strong>step_q</strong> (<em>float</em>) – reactive power resolution [mvar].</p></li>
<li><p><strong>x_axis</strong> (<em>list</em>) – x-axis values.</p></li>
<li><p><strong>y_axis</strong> (<em>list</em>) – y-axis values.</p></li>
<li><p><strong>maxv</strong> (<em>list</em>) – maximum voltages [p.u.].</p></li>
<li><p><strong>minv</strong> (<em>list</em>) – minimum voltages [p.u.].</p></li>
<li><p><strong>maxl</strong> (<em>list</em>) – maximum absolute loading [%].</p></li>
<li><p><strong>cost</strong> (<em>list</em>) – costs for flexibility point [euro].</p></li>
<li><p><strong>used_fsps</strong> (<em>list</em>) – minimum fsps used for each flexibility point [int].</p></li>
<li><p><strong>selected_pts</strong> (<em>dictionary</em>) – selected points to study.</p></li>
<li><p><strong>prof_flex</strong> (<em>list</em>) – flexible profiles.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>matrices for number of feasible combinations (feas_mat), DFC (heat_mat), non-flexible combinations
(nflex_mat), minimum maximum voltages (min_vxmat), maximum maximum voltages (max_vxmat),
minimum minimum voltages (min_vnmat), maximum minimum voltages (max_vnmat), minimum loading (min_lmat),
maximum loading (max_lmat), minimum costs (min_cmat), maximum costs (max_cmat), minumum used FSPs (min_umat),
maximum used FSPs (max_umat), values for scenarios (v_plot).</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>lists</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py">
<span class="sig-prename descclassname"><span class="pre">accuracy_estimation.</span></span><span class="sig-name descname"><span class="pre">info_options</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x_flexible</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">x_non_flexible</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y_flexible</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y_non_flexible</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dp</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dq</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">maxv</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">minv</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">maxl</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cost</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">used_fsps</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">prof_flex</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>This function plots and prints information for the case study ‘DFC Improving TSOs Flexibility Shift Selection’.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>x_flexible</strong> (<em>list</em>) – flexible pcc p</p></li>
<li><p><strong>x_non_flexible</strong> (<em>list</em>) – non-flexible pcc p</p></li>
<li><p><strong>y_flexible</strong> (<em>list</em>) – flexible pcc q</p></li>
<li><p><strong>y_non_flexible</strong> (<em>list</em>) – non flexible pcc q</p></li>
<li><p><strong>dp</strong> (<em>float</em>) – active power resolution [mw]</p></li>
<li><p><strong>dq</strong> (<em>float</em>) – reactive power resolution [mvar]</p></li>
<li><p><strong>maxv</strong> (<em>list</em>) – maximmum voltages [p.u.]</p></li>
<li><p><strong>minv</strong> (<em>list</em>) – minimum voltages [p.u.]</p></li>
<li><p><strong>maxl</strong> (<em>list</em>) – maximum absolute loading [%]</p></li>
<li><p><strong>cost</strong> (<em>list</em>) – costs for flexiiblity point [euro]</p></li>
<li><p><strong>used_fsps</strong> (<em>list</em>) – minimum fsps used for each flexibility point [int]</p></li>
<li><p><strong>prof_flex</strong> (<em>list</em>) – flexible profiles</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p></p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p></p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py">
<span class="sig-prename descclassname"><span class="pre">accuracy_estimation.</span></span><span class="sig-name descname"><span class="pre">loop_acc</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">ground_truth</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">conv_results</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">inf</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>Calculate and return accuracy metrics for UC2 scenarios.
This function calculates accuracy metrics for the UC2 scenarios based on ground truth data, convex results,
and infeasible points. It takes ground truth data, convex results, infeasible points, and a name for the plot.
It calculates feasibility accuracy and available accuracy and returns their averages.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>ground_truth</strong> (<em>pandas.DataFrame</em>) – A DataFrame containing ground truth data.</p></li>
<li><p><strong>conv_results</strong> (<em>pandas.DataFrame</em>) – A DataFrame containing convex results.</p></li>
<li><p><strong>inf</strong> (<em>pandas.DataFrame</em>) – A DataFrame representing infeasible points.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>feasibility accuracy, available accuracy, average accuracy, a placeholder 0.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>float, float, flaot, float</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py">
<span class="sig-prename descclassname"><span class="pre">accuracy_estimation.</span></span><span class="sig-name descname"><span class="pre">plot_results</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">ground_truth</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">conv_results</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">inf</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">name</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">x_axis</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y_axis</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>Generate a visualization of feasible and infeasible regions.
This function generates a visualization of feasible and infeasible regions using input data.
It takes ground truth data, convex results, infeasible points, a name for the plot, and axis values.
The regions are plotted, and the resulting plot is saved as a PDF file.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>ground_truth</strong> (<em>pandas.DataFrame</em>) – A DataFrame containing ground truth data.</p></li>
<li><p><strong>conv_results</strong> (<em>pandas.DataFrame</em>) – A DataFrame containing convex results.</p></li>
<li><p><strong>inf</strong> (<em>pandas.DataFrame</em>) – A DataFrame representing infeasible points.</p></li>
<li><p><strong>name</strong> (<em>str</em>) – The name of the plot and output PDF file.</p></li>
<li><p><strong>x_axis</strong> (<em>list</em>) – The x-axis values.</p></li>
<li><p><strong>y_axis</strong> (<em>list</em>) – The y-axis values.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p></p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p></p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py">
<span class="sig-prename descclassname"><span class="pre">accuracy_estimation.</span></span><span class="sig-name descname"><span class="pre">range_acc_case_study</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">net</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">settings</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">pcc_operating_point</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>Run some simulations for range accuracy case study.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>net</strong> (<em>pandapower.network</em>) – network.</p></li>
<li><p><strong>settings</strong> (<em>object</em>) – scenario settings.</p></li>
<li><p><strong>pcc_operating_point</strong> (<em>list</em><em>[</em><em>float</em><em>, </em><em>float</em><em>]</em>) – initial PQ values at the PCC.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p></p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p></p>
</dd>
</dl>
</dd></dl>

</section>
<section id="utils">
<h3>Utils<a class="headerlink" href="#utils" title="Link to this heading"></a></h3>
<p>This Python Script includes all generic functions.</p>
<dl class="py function">
<dt class="sig sig-object py">
<span class="sig-prename descclassname"><span class="pre">utils.</span></span><span class="sig-name descname"><span class="pre">assert_limits</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">net</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">settings</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>Check that the network operates within the operation limits and assert an error if not</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>net</strong> (<em>pandapower.network</em>) – network</p></li>
<li><p><strong>settings</strong> (<em>object</em>) – scenario settings</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p></p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p></p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py">
<span class="sig-prename descclassname"><span class="pre">utils.</span></span><span class="sig-name descname"><span class="pre">check_limits</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">net</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">settings</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>Check that the network operates within the operation limits and print it</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>net</strong> (<em>pandapower.network</em>) – network</p></li>
<li><p><strong>settings</strong> (<em>object</em>) – scenario settings</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p></p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p></p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py">
<span class="sig-prename descclassname"><span class="pre">utils.</span></span><span class="sig-name descname"><span class="pre">check_limits_bool</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">net</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">settings</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>Check that the network operates within the operation limits and return True(feasible)/False(not feasible)</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>net</strong> (<em>pandapower.network</em>) – network</p></li>
<li><p><strong>settings</strong> (<em>object</em>) – scenario settings</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p></p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p></p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py">
<span class="sig-prename descclassname"><span class="pre">utils.</span></span><span class="sig-name descname"><span class="pre">check_line_current_limits</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">net</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">upper_limit</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">100</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>Check if the power flow result on the network caused respects the loading limitations in all lines</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>net</strong> (<em>pandapower.network</em>) – network model</p></li>
<li><p><strong>upper_limit</strong> (<em>int/float</em>) – upper loading percentage limit</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>True/False if the loading of any line exceeds the upper limit</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>boolean</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py">
<span class="sig-prename descclassname"><span class="pre">utils.</span></span><span class="sig-name descname"><span class="pre">check_trafo_current_limits</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">net</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">upper_limit</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">100</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>Check if the power flow result on the network caused respects the loading limitations in all transformers</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>net</strong> (<em>pandapower.network</em>) – network model</p></li>
<li><p><strong>upper_limit</strong> (<em>int/float</em>) – upper loading percentage limit</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>True/False if the loading of any line exceeds the upper limit</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>boolean</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py">
<span class="sig-prename descclassname"><span class="pre">utils.</span></span><span class="sig-name descname"><span class="pre">check_voltage_limits</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">voltages</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">upper_limit</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">lower_limit</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>Check if the power flow result on the network caused respects the voltage limitations in all lines</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>voltages</strong> (<em>list</em><em> of </em><em>floats</em>) – list of component voltages to be evaluated</p></li>
<li><p><strong>upper_limit</strong> (<em>float</em>) – upper voltage percentage limit</p></li>
<li><p><strong>lower_limit</strong> (<em>int/float</em>) – lower voltage percentage limit [float]</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>True/False if the voltage of any component exceeds the upper limit, or is lower than the lower limit</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>boolean</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py">
<span class="sig-prename descclassname"><span class="pre">utils.</span></span><span class="sig-name descname"><span class="pre">create_result_df</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x_flexible</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">x_non_flexible</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y_flexible</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y_non_flexible</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>Sve Monte Carlo simulation result on the folder
:param x_flexible: feasible P,
:type x_flexible: list of floats</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>x_non_flexible</strong> (<em>list</em><em> of </em><em>floats</em>) – infeasible P,</p></li>
<li><p><strong>y_flexible</strong> (<em>list</em><em> of </em><em>floats</em>) – feasible Q,</p></li>
<li><p><strong>y_non_flexible</strong> (<em>list</em><em> of </em><em>floats</em>) – infeasible Q,</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p></p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p></p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py">
<span class="sig-prename descclassname"><span class="pre">utils.</span></span><span class="sig-name descname"><span class="pre">fix_missing_point</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mat</span></span></em><span class="sig-paren">)</span></dt>
<dd><dl class="simple">
<dt>Filter in case the sampling of FSP shifts was wrong and left a point behind, it is observed in the power flow</dt><dd><p>results if the sensitivity of a pixel is 0, but the upper, lower, left, and right values are non-zero. In that
case, take their average.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>mat</strong> (<em>np.array</em>) – Array with sensitivities or binary values</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>The input array fixed for these issue</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>np.array</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py">
<span class="sig-prename descclassname"><span class="pre">utils.</span></span><span class="sig-name descname"><span class="pre">fix_missing_pointsv2</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mat</span></span></em><span class="sig-paren">)</span></dt>
<dd><dl class="simple">
<dt>Filter in case the sampling of FSP shifts was wrong and left a point behind, it is observed in the power flow</dt><dd><p>results if the sensitivity of a pixel is 0, but the upper, lower, left, and right values are non-zero. In that
case, take their average.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>mat</strong> (<em>np.array</em>) – Array with sensitivities or binary values</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>The input array fixed for these issue</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>np.array</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py">
<span class="sig-prename descclassname"><span class="pre">utils.</span></span><span class="sig-name descname"><span class="pre">fix_net</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">net</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>Fix the initial network structure</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>net</strong> (<em>pandapower network</em>) – network for the case studies</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>fixed network</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>pandapower network</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py">
<span class="sig-prename descclassname"><span class="pre">utils.</span></span><span class="sig-name descname"><span class="pre">get_input_busses_pq</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">net</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">input_buses</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>Get P and Q of all bus indices in {input_buses} list</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>net</strong> (<em>pandapower network</em>) – network model</p></li>
<li><p><strong>input_buses</strong> (<em>list</em><em> of </em><em>int</em>) – bus indices whose P,Q values are needed</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>p= list of P of busses of interest, q= list of Q of busses of interest</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>list, list</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py">
<span class="sig-prename descclassname"><span class="pre">utils.</span></span><span class="sig-name descname"><span class="pre">get_input_busses_v</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">net</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">input_buses</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>Get voltage magnitude v and angle θ of all bus indices in {input_buses} list</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>net</strong> (<em>pandapower network</em>) – network model</p></li>
<li><p><strong>input_buses</strong> (<em>list</em><em> of </em><em>ints</em>) – bus indices whose v, θ values are needed</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>p= list of v of busses of interest, q= list of θ of busses of interest</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>list, list</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py">
<span class="sig-prename descclassname"><span class="pre">utils.</span></span><span class="sig-name descname"><span class="pre">get_input_lines_pq</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">net</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">input_lines</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>Get P and Q of all line indices in {input_lines} list</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>net</strong> (<em>pandapower network</em>) – network model,</p></li>
<li><p><strong>input_buses</strong> (<em>list</em><em> of </em><em>int</em>) – line indices whose P,Q values are needed,</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>p= list of P of lines of interest, q= list of Q of lines of interest</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>list, list</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py">
<span class="sig-prename descclassname"><span class="pre">utils.</span></span><span class="sig-name descname"><span class="pre">kumaraswamymontecarlo</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">a</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">b</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">c</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">LB</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">UB</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">num_samples</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">rng</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>Create samples using the Kumaraswamy Monte Carlo distribution</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>a</strong> (<em>float</em>) – alpha</p></li>
<li><p><strong>b</strong> (<em>float</em>) – beta</p></li>
<li><p><strong>c</strong> (<em>float</em>) – gamma</p></li>
<li><p><strong>LB</strong> (<em>float</em>) – lower bound</p></li>
<li><p><strong>UB</strong> (<em>float</em>) – upper bound</p></li>
<li><p><strong>num_samples</strong> (<em>int</em>) – number of samples</p></li>
<li><p><strong>rng</strong> (<em>numpy.random</em>) – object to sample data from</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>samples</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>numpy array</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py">
<span class="sig-prename descclassname"><span class="pre">utils.</span></span><span class="sig-name descname"><span class="pre">tensor_convolve_nd_torch</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">image</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">kernel</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>Apply tensor convolution</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>image</strong> (<em>torch tensor</em>) – multi-dim tensor</p></li>
<li><p><strong>kernel</strong> (<em>torch tensor</em>) – 2D tensor</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>tensor convolution result</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>torch tensor</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py">
<span class="sig-prename descclassname"><span class="pre">utils.</span></span><span class="sig-name descname"><span class="pre">tensor_convolve_nd_torch_half</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">image</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">kernel</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>Apply tensor convolution, but with float32 types (might run into issues exceeding the maximum number)</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>image</strong> (<em>torch tensor</em>) – multi-dim tensor</p></li>
<li><p><strong>kernel</strong> (<em>torch tensor</em>) – 2D tensor</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>tensor convolution result</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>torch tensor</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py">
<span class="sig-prename descclassname"><span class="pre">utils.</span></span><span class="sig-name descname"><span class="pre">update_pqs</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">net</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">flex_wt</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">flex_pv</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">profile</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">scale_w</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">scale_pv</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>Update network DG FSP P,Q based on the input values</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>net</strong> (<em>pandapower network</em>) – network model</p></li>
<li><p><strong>flex_wt</strong> (<em>list</em><em> of </em><em>int</em>) – Indices of flexible wind turbines,</p></li>
<li><p><strong>flex_pv</strong> (<em>list</em><em> of </em><em>int</em>) – Indices of flexible pv,</p></li>
<li><p><strong>profile</strong> (<em>list</em><em> of </em><em>lists</em><em> of </em><em>floats</em>) – P,Q values for each FSP for one iteration on the Monte Carlo algorithm</p></li>
<li><p><strong>scale_w</strong> (<em>int/float</em>) – If a network with different wt penetration is used, this parameter will scale the wt accordingly,
(default=1, no scaling)</p></li>
<li><p><strong>scale_pv</strong> (<em>int/float</em>) – If a network with different pv penetration is used, this parameter will scale the pv accordingly,
(default=1, no scaling)</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>updated network model</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>pandapower network</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py">
<span class="sig-prename descclassname"><span class="pre">utils.</span></span><span class="sig-name descname"><span class="pre">update_pqs2</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">net</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">flex_dg</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">profile</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>Update network DG FSP P,Q based on the input profile</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>net</strong> (<em>pandapower network</em>) – network model,</p></li>
<li><p><strong>flex_dg</strong> (<em>list</em><em> of </em><em>int</em>) – Indices of flexible distributed generation,</p></li>
<li><p><strong>profile</strong> (<em>list</em><em> of </em><em>list</em><em> of </em><em>floats</em>) – P,Q values for each FSP for one iteration on the Monte Carlo algorithm</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>updated network model</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>pandapower network</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py">
<span class="sig-prename descclassname"><span class="pre">utils.</span></span><span class="sig-name descname"><span class="pre">update_pqs_wl</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">net</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">flex_wt</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">flex_pv</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">profile</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">scale_w</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1.0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">scale_pv</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1.0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">load_ind</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">[]</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>Update network FSP P,Q including loads based on the input values</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>net</strong> (<em>pandapower network</em>) – network model</p></li>
<li><p><strong>flex_wt</strong> (<em>list</em><em> of </em><em>int</em>) – indices of flexible wind turbines</p></li>
<li><p><strong>flex_pv</strong> (<em>list</em><em> of </em><em>int</em>) – indices of flexible pv,</p></li>
<li><p><strong>profile</strong> (<em>list</em><em> of </em><em>(</em><em>FSPs</em><em>) </em><em>list</em><em> of </em><em>(</em><em>P</em><em>,</em><em>Q</em><em>) </em><em>floats</em>) – P,Q values for each FSP for one iteration on the Monte Carlo algorithm</p></li>
<li><p><strong>scale_w</strong> (<em>int/float</em>) – if a network with different wt penetration is used, this parameter will scale the wt accordingly, (default=1, no scaling),</p></li>
<li><p><strong>scale_pv</strong> (<em>int/float</em>) – If a network with different pv penetration is used, this parameter will scale the pv accordingly (default=1, no scaling),</p></li>
<li><p><strong>load_ind</strong> (<em>list</em><em> of </em><em>int</em>) – indices of flexible loads</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>net=updated network model</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>pandaPower network</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py">
<span class="sig-prename descclassname"><span class="pre">utils.</span></span><span class="sig-name descname"><span class="pre">update_pqs_wl2</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">net</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">profile</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">load_ind</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">[]</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dg_ind</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">[]</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>Update load and distributed generator output values.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>net</strong> (<em>pandapower network</em>) – network model</p></li>
<li><p><strong>profile</strong> (<em>list</em>) – profile with values to update</p></li>
<li><p><strong>load_ind</strong> (<em>list</em>) – indices of loads to update</p></li>
<li><p><strong>dg_ind</strong> (<em>list</em>) – indices of distributed generators to update</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>updated network</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>pandapower network</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py">
<span class="sig-prename descclassname"><span class="pre">utils.</span></span><span class="sig-name descname"><span class="pre">update_pqs_wl2_aliander</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">net</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">profile</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">load_ind</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">[]</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dg_ind</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">[]</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>Update PQ values using Aliander’s PGM</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>net</strong> (<em>pandapower model</em>) – network model</p></li>
<li><p><strong>profile</strong> (<em>list</em>) – values for network components</p></li>
<li><p><strong>load_ind</strong> (<em>list</em>) – load indices to update the values</p></li>
<li><p><strong>dg_ind</strong> (<em>lost</em>) – distributed generation indices to update the values</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>updated network model</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>pandapower network</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py">
<span class="sig-prename descclassname"><span class="pre">utils.</span></span><span class="sig-name descname"><span class="pre">write_conv_result</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">df</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">name</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>Write results from convolution simulations</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>df</strong> (<em>pandas.dataframe</em>) – dataframe with results</p></li>
<li><p><strong>name</strong> (<em>str</em>) – name of scenario</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p></p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p></p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py">
<span class="sig-prename descclassname"><span class="pre">utils.</span></span><span class="sig-name descname"><span class="pre">write_result</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x_flexible</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">x_non_flexible</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y_flexible</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y_non_flexible</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">name</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>Sve Monte Carlo simulation result on the folder</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>x_flexible</strong> (<em>list</em><em> of </em><em>floats</em>) – feasible P</p></li>
<li><p><strong>x_non_flexible</strong> (<em>list</em><em> of </em><em>floats</em>) – infeasible P</p></li>
<li><p><strong>y_flexible</strong> (<em>list</em><em> of </em><em>floats</em>) – feasible Q</p></li>
<li><p><strong>y_non_flexible</strong> (<em>list</em><em> of </em><em>floats</em>) – infeasible Q</p></li>
<li><p><strong>name</strong> (<em>str</em>) – name to be used in filename,</p></li>
</ul>
</dd>
</dl>
</dd></dl>

</section>
<section id="optimal-power-flow">
<h3>Optimal power flow<a class="headerlink" href="#optimal-power-flow" title="Link to this heading"></a></h3>
<p>This Python Script includes the functions used for the opf.</p>
<dl class="py function">
<dt class="sig sig-object py">
<span class="sig-prename descclassname"><span class="pre">opf.</span></span><span class="sig-name descname"><span class="pre">opf_fa_pck</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">net1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fsps_dg</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">[2,</span> <span class="pre">4,</span> <span class="pre">6]</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fsps_load</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">[14,</span> <span class="pre">16]</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">filename</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">''</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">opf_step</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">0.1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">max_curr_per</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">100</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">max_volt_pu</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">1.05</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">min_volt_pu</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">0.95</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>Estimate flexibility area using OPF method.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>net1</strong> (<em>pandapower network</em>) – network.</p></li>
<li><p><strong>fsps_dg</strong> (<em>list</em><em>[</em><em>int</em><em>]</em>) – distributed generators offering flexibility.</p></li>
<li><p><strong>fsps_load</strong> (<em>list</em><em>[</em><em>int</em><em>]</em>) – loads offering flexibility.</p></li>
<li><p><strong>filename</strong> (<em>str</em>) – name to use in the plot.</p></li>
<li><p><strong>opf_step</strong> (<em>float</em>) – step size for optimization. Default=0.1.</p></li>
<li><p><strong>max_curr_per</strong> (<em>int</em>) – network maximum current constraint (optional). Default=100.</p></li>
<li><p><strong>max_volt_pu</strong> (<em>float</em>) – network maximum voltage constraint (optional). Default=1.05.</p></li>
<li><p><strong>min_volt_pu</strong> (<em>float</em>) – network minimum voltage constraint (optional). Default=0.95.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p></p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p></p>
</dd>
</dl>
</dd></dl>

</section>
<section id="main">
<h3>Main<a class="headerlink" href="#main" title="Link to this heading"></a></h3>
<p>This python script is the main file calling the rest of the scripts.</p>
</section>
</section>
<section id="vi-files-for-ieee-transactions-on-smart-grid-publication-scenarios">
<h2>VI. Files for IEEE Transactions on Smart Grid Publication Scenarios<a class="headerlink" href="#vi-files-for-ieee-transactions-on-smart-grid-publication-scenarios" title="Link to this heading"></a></h2>
<p>To run use case scenarios, you can use the json files under the <code class="docutils literal notranslate"><span class="pre">scenarios</span></code> folder. The scripts used are under the <strong>src/SmartGridScripts/</strong> folder</p>
<section id="vi-a-accuracy-in-population-estimation">
<h3>VI.A) Accuracy in Population Estimation<a class="headerlink" href="#vi-a-accuracy-in-population-estimation" title="Link to this heading"></a></h3>
<p>The result files are in the <strong>csv_results/UC1</strong> folder.
Example figures generated for these scenarios are in the folder <strong>plots/UC1</strong></p>
<a class="reference internal image-reference" href="/plots/UC1/Compare_Flexibility_area_BruteOb0_2.svg"><img alt="/plots/UC1/Compare_Flexibility_area_BruteOb0_2.svg" src="/plots/UC1/Compare_Flexibility_area_BruteOb0_2.svg" width="400" /></a>
<a class="reference internal image-reference" href="/plots/UC1/Conv_multi_Conv_Conv_Brute_Ob0_2.svg"><img alt="/plots/UC1/Conv_multi_Conv_Conv_Brute_Ob0_2.svg" src="/plots/UC1/Conv_multi_Conv_Conv_Brute_Ob0_2.svg" width="400" /></a>
</section>
<section id="vi-b-speed-and-range-accuracy">
<h3>VI.B) Speed and Range Accuracy<a class="headerlink" href="#vi-b-speed-and-range-accuracy" title="Link to this heading"></a></h3>
<p>The CSV results are under <strong>csv_results/UC2</strong>
The figures are saved under <strong>plots/UC2</strong></p>
<a class="reference internal image-reference" href="/plots/UC2/Loop/Kumaraswamy_MC_Oberrhein0_4FSPs_20_8.svg"><img alt="/plots/UC2/Loop/Kumaraswamy_MC_Oberrhein0_4FSPs_20_8.svg" src="/plots/UC2/Loop/Kumaraswamy_MC_Oberrhein0_4FSPs_20_8.svg" width="400" /></a>
<a class="reference internal image-reference" href="/plots/UC2/Loop/Uniform_MC_Oberrhein0_4FSPs_20_8.svg"><img alt="/plots/UC2/Loop/Uniform_MC_Oberrhein0_4FSPs_20_8.svg" src="/plots/UC2/Loop/Uniform_MC_Oberrhein0_4FSPs_20_8.svg" width="400" /></a>
<a class="reference internal image-reference" href="/plots/UC2/Loop/Hard_MC_Oberrhein0_4FSPs_20_8.svg"><img alt="/plots/UC2/Loop/Hard_MC_Oberrhein0_4FSPs_20_8.svg" src="/plots/UC2/Loop/Hard_MC_Oberrhein0_4FSPs_20_8.svg" width="400" /></a>
<a class="reference internal image-reference" href="/plots/UC2/Oberrhein0_speed_log.svg"><img alt="/plots/UC2/Oberrhein0_speed_log.svg" src="/plots/UC2/Oberrhein0_speed_log.svg" width="400" /></a>
<a class="reference internal image-reference" href="/plots/UC2/Oberrhein0W_speed_log.svg"><img alt="/plots/UC2/Oberrhein0W_speed_log.svg" src="/plots/UC2/Oberrhein0W_speed_log.svg" width="400" /></a>
<a class="reference internal image-reference" href="/plots/UC2/Oberrhein1_speed_log.svg"><img alt="/plots/UC2/Oberrhein1_speed_log.svg" src="/plots/UC2/Oberrhein1_speed_log.svg" width="400" /></a>
<a class="reference internal image-reference" href="/plots/UC2/Conv_multi_Conv_LargeRadial.svg"><img alt="/plots/UC2/Conv_multi_Conv_LargeRadial.svg" src="/plots/UC2/Conv_multi_Conv_LargeRadial.svg" width="400" /></a>
</section>
<section id="vi-c-disjoint-flexibility-areas">
<h3>VI.C) Disjoint Flexibility Areas<a class="headerlink" href="#vi-c-disjoint-flexibility-areas" title="Link to this heading"></a></h3>
<p>The result files are in the <strong>csv_results/UC3</strong> folder.
Example figures generated for these scenarios are in the folder <strong>plots/UC3</strong></p>
<a class="reference internal image-reference" href="/plots/UC3/Disc_Scenario_121416012388_incl_infeasible.jpg"><img alt="/plots/UC3/Disc_Scenario_121416012388_incl_infeasible.jpg" src="/plots/UC3/Disc_Scenario_121416012388_incl_infeasible.jpg" style="width: 400px;" /></a>
<a class="reference internal image-reference" href="/plots/UC3/Conv_multi_Conv_Conv_Discontinuous.svg"><img alt="/plots/UC3/Conv_multi_Conv_Conv_Discontinuous.svg" src="/plots/UC3/Conv_multi_Conv_Conv_Discontinuous.svg" width="400" /></a>
</section>
<section id="vi-d-uncertainty-estimation-for-small-fsps">
<h3>VI.D) Uncertainty Estimation for Small FSPs<a class="headerlink" href="#vi-d-uncertainty-estimation-for-small-fsps" title="Link to this heading"></a></h3>
<p>The results are in the <strong>csv_results/UC4</strong> folder.
Example figure generated for the scenario is in the folder <strong>plots/UC4</strong></p>
<a class="reference internal image-reference" href="/plots/UC4/Uncertainty_Interpreted.png"><img alt="/plots/UC4/Uncertainty_Interpreted.png" src="/plots/UC4/Uncertainty_Interpreted.png" style="width: 400px;" /></a>
</section>
<section id="vi-e-adaptability">
<h3>VI.E) Adaptability<a class="headerlink" href="#vi-e-adaptability" title="Link to this heading"></a></h3>
<p>Example results from the case study can be found in the <strong>csv_results/UC5</strong> folder.
Example plots are in the <strong>plots/UC5</strong> folder:</p>
<a class="reference internal image-reference" href="/plots/UC5/TCP_Conv_SaveTsOb0.svg"><img alt="/plots/UC5/TCP_Conv_SaveTsOb0.svg" src="/plots/UC5/TCP_Conv_SaveTsOb0.svg" width="400" /></a>
<a class="reference internal image-reference" href="/plots/UC5/TCP_Conv_NoLoadFlexOb0.svg"><img alt="/plots/UC5/TCP_Conv_NoLoadFlexOb0.svg" src="/plots/UC5/TCP_Conv_NoLoadFlexOb0.svg" width="400" /></a>
<a class="reference internal image-reference" href="/plots/UC5/TCP_Conv_LoadFlexOb0.svg"><img alt="/plots/UC5/TCP_Conv_LoadFlexOb0.svg" src="/plots/UC5/TCP_Conv_LoadFlexOb0.svg" width="400" /></a>
<a class="reference internal image-reference" href="/plots/UC5/TCP_Conv_SaveFaTs.svg"><img alt="/plots/UC5/TCP_Conv_SaveFaTs.svg" src="/plots/UC5/TCP_Conv_SaveFaTs.svg" width="400" /></a>
<a class="reference internal image-reference" href="/plots/UC5/TCP_Conv_NoLoadTs_ax.svg"><img alt="/plots/UC5/TCP_Conv_NoLoadTs_ax.svg" src="/plots/UC5/TCP_Conv_NoLoadTs_ax.svg" width="400" /></a>
<a class="reference internal image-reference" href="/plots/UC5/TCP_Conv_LoadTs_ax.svg"><img alt="/plots/UC5/TCP_Conv_LoadTs_ax.svg" src="/plots/UC5/TCP_Conv_LoadTs_ax.svg" width="400" /></a>
</section>
<section id="vi-f-case-study-for-dfc">
<h3>VI.F) Case study for DFC<a class="headerlink" href="#vi-f-case-study-for-dfc" title="Link to this heading"></a></h3>
<p>The results are in the <strong>csv_results/UC6</strong> folder.
Example figures generated for the scenario are in the folder <strong>plots/UC6</strong></p>
<a class="reference internal image-reference" href="/plots/UC6/feas_mat.svg"><img alt="/plots/UC6/feas_mat.svg" src="/plots/UC6/feas_mat.svg" width="250" /></a>
<a class="reference internal image-reference" href="/plots/UC6/heat_mat.svg"><img alt="/plots/UC6/heat_mat.svg" src="/plots/UC6/heat_mat.svg" width="250" /></a>
<a class="reference internal image-reference" href="/plots/UC6/min_cmat.svg"><img alt="/plots/UC6/min_cmat.svg" src="/plots/UC6/min_cmat.svg" width="250" /></a>
<a class="reference internal image-reference" href="/plots/UC6/nflex_mat.svg"><img alt="/plots/UC6/nflex_mat.svg" src="/plots/UC6/nflex_mat.svg" width="250" /></a>
</section>
<section id="vi-g-case-study-for-opfs">
<h3>VI.G) Case study for OPFs<a class="headerlink" href="#vi-g-case-study-for-opfs" title="Link to this heading"></a></h3>
<p>Example figure generated for this scenario is in the folder <strong>plots/UC7</strong></p>
<a class="reference internal image-reference" href="/plots/UC7/OPF_.svg"><img alt="/plots/UC7/OPF_.svg" src="/plots/UC7/OPF_.svg" width="500" /></a>
</section>
</section>
</section>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="index.html" class="btn btn-neutral float-left" title="Welcome to TensorConvolutionPlus’s documentation!" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="api.html" class="btn btn-neutral float-right" title="API" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2024, Demetris Chrysostomou.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>